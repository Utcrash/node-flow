{
    "dataFormatList": [],
    "dataPipeList": [],
    "version": 1,
    "nodeList": [
        {
            "_id": "661d7844dd0a8ba74ebbab7f",
            "_deleted": false,
            "_version": 20,
            "category": "TRIGGER",
            "group": "Misc",
            "type": "V1_TIMER",
            "connectorType": "NONE",
            "label": "Timer",
            "icon": "ni ni-timer",
            "version": 1,
            "inputSchema": [
                {
                    "key": "cron",
                    "type": "String"
                },
                {
                    "key": "holidayList",
                    "type": "Array",
                    "subType": "String"
                },
                {
                    "key": "timezone",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "timestamp",
                    "type": "Datetime"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": "const { CronJob } = require('cron');\ntry {\n    console.log('InputData - ', inputData);\n    let timezone = (inputData.timezone && inputData.timezone.trim() !== '' && inputData.timezone.trim().toLowerCase() !== 'undefined') ? inputData.timezone : 'UTC';\n    console.log('Timezone - ', timezone);\n    const job = new CronJob(inputData.cron, async () => {\n        try {\n            const date = new Date();\n            const isoString = date.toISOString();\n            const payload = { timestamp: isoString };\n            const headers = { 'dnio-remote-txn-id': isoString };\n            StartProcess(payload, headers);\n            return { timestamp: isoString };\n        } catch (err) {\n            logger.error('TimerError - ', err);\n        }\n    },\n        null,\n        true,\n        timezone\n    );\n} catch (e) {\n    logger.error(`Failed to schedule cron job for expression \"${inputData.cron}\": ${e.message}`);\n}",
            "_lastUpdated": "2025-05-16T08:51:26.768Z",
            "_createdAt": "2024-04-15T18:56:04.638Z",
            "nodeId": "1d87dccc33d3657786414c387e9a8e72cdaabf656b5983345959070ea3501c56",
            "__v": 5,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbab80",
            "_deleted": false,
            "_version": 3,
            "category": "TRIGGER",
            "group": "HTTP",
            "type": "V1_HTTP_SERVER",
            "connectorType": "NONE",
            "label": "HTTP Server",
            "icon": "ni ni-http-server",
            "version": 1,
            "inputSchema": [
                {
                    "key": "method",
                    "type": "String"
                },
                {
                    "key": "path",
                    "type": "String"
                },
                {
                    "key": "uniqueTxn",
                    "type": "Boolean"
                },
                {
                    "key": "enableAuth",
                    "type": "Boolean"
                }
            ],
            "outputSchema": [
                {
                    "key": "query",
                    "type": "KeyValPair"
                },
                {
                    "key": "headers",
                    "type": "KeyValPair"
                },
                {
                    "key": "data",
                    "type": "Buffer"
                },
                {
                    "key": "method",
                    "type": "String"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": "",
            "_lastUpdated": "2025-04-29T02:40:21.737Z",
            "_createdAt": "2024-04-15T18:56:04.638Z",
            "nodeId": "a06a6c70359655ecdac9d297a854fe302091827d3016cc0d041b0694f0fbe53f",
            "__v": 1,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbab81",
            "_deleted": false,
            "_version": 3,
            "category": "TRIGGER",
            "group": "Queue",
            "type": "V1_KAFKA_SUBSCRIBER",
            "connectorType": "KAFKA",
            "label": "Kafka Listener",
            "icon": "ni ni-queue-subscribe",
            "version": 1,
            "inputSchema": [
                {
                    "key": "topic",
                    "type": "String"
                },
                {
                    "key": "groupId",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": "const { Kafka } = require('kafkajs');\nconst kafkaOptions = {\n    clientId: connectorData.clientId,\n    brokers: connectorData.brokers\n};\nif (connectorData.ssl) {\n    kafkaOptions.ssl = connectorData.ssl;\n}\nif (connectorData.sasl) {\n    kafkaOptions.sasl = {\n        mechanism: 'plain',\n        username: connectorData.username,\n        password: connectorData.password,\n    };\n}\nlogger.trace(`Kafka config - ${JSON.stringify(kafkaOptions)}`)\nconst kafka = new Kafka(kafkaOptions);\nconst consumer = kafka.consumer({ groupId: inputData.groupId });\nconst runConsumer = async () => {\n    await consumer.connect();\n    await consumer.subscribe({ topic: inputData.topic });\n    await consumer.run({\n        eachMessage: async ({ topic, partition, message }) => {\n            logger.info('Received a message:', message);\n            StartProcess(message.value)\n        }\n    });\n};\nrunConsumer().catch(logger.error);",
            "_lastUpdated": "2025-09-14T05:43:13.041Z",
            "_createdAt": "2024-04-15T18:56:04.638Z",
            "nodeId": "9bd17209f1a68849421f7a4ed22c7ac181ee115a15f9c5ddddd22585bf2bf288",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbab82",
            "_deleted": false,
            "_version": 3,
            "category": "TRIGGER",
            "group": "Queue",
            "type": "V1_NATS_SUBSCRIBER",
            "connectorType": "NATS",
            "label": "NATS Listener",
            "icon": "ni ni-queue-subscribe",
            "version": 1,
            "inputSchema": [
                {
                    "key": "queue",
                    "type": "String"
                },
                {
                    "key": "clientId",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": "(async () => {\n    const subs = connectorData.natsCon.subscribe(inputData.queue, { queue: inputData.clientId });\n    for await (let sub of subs) {\n        StartProcess({ data: sub.data });\n    }\n})();",
            "_lastUpdated": "2025-03-18T14:15:15.408Z",
            "_createdAt": "2024-04-15T18:56:04.638Z",
            "nodeId": "c724a4c25548e29591f53fd99882ed8310f08b50acc7ce1e0e2d59b08b63bb0d",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbab83",
            "_deleted": false,
            "_version": 2,
            "category": "TRIGGER",
            "group": "Queue",
            "type": "V1_ACTIVEMQ_SUBSCRIBER",
            "connectorType": "ACTIVEMQ",
            "label": "ActiveMQ Listener",
            "icon": "ni ni-queue-subscribe",
            "version": 1,
            "inputSchema": [
                {
                    "key": "queue",
                    "type": "String"
                },
                {
                    "key": "clientId",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [],
            "_lastUpdated": "2024-04-15T18:56:04.638Z",
            "_createdAt": "2024-04-15T18:56:04.638Z",
            "nodeId": "8b0b5f051717a87ef1363c006853d8525fbab950e645d9c718895eb919b87837",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbab84",
            "_deleted": false,
            "_version": 2,
            "category": "TRIGGER",
            "group": "Queue",
            "type": "V1_IBM_MQ_CONSUME",
            "connectorType": "IBMMQ",
            "label": "IBM MQ Consume",
            "icon": "ni ni-queue-subscribe",
            "version": 1,
            "inputSchema": [
                {
                    "key": "queue",
                    "type": "String"
                },
                {
                    "key": "messageSize",
                    "type": "Number"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [
                "const mq = require('ibmmq');",
                "const MQC = mq.MQC;",
                "function openQueue(client, MQDetails) {",
                "    let openOptions = MQC.MQOO_INPUT_AS_Q_DEF;",
                "    let objectDescriptor = new mq.MQOD();",
                "    objectDescriptor.ObjectName = MQDetails.queue;",
                "    objectDescriptor.ObjectType = MQC.MQOT_Q;",
                "    return new Promise((resolve, reject) => {",
                "        mq.Open(client, objectDescriptor, openOptions, function (err, queueClient) {",
                "            if (err) {",
                "                logger.error('Error Subscribing IBM MQ Queue :', err);",
                "                reject(err);",
                "            } else {",
                "                logger.info('IBM MQ Queue Opened :', MQDetails.queue);",
                "                resolve(queueClient);",
                "            }",
                "        });",
                "    })",
                "}",
                "function getMessage(queueClient) {",
                "    let buffer = Buffer.alloc(inputData.messageSize || 1024);",
                "    let messageDescriptor = new mq.MQMD();",
                "    let getMessageOptions = new mq.MQGMO();",
                "    getMessageOptions.Options = MQC.MQGMO_NO_SYNCPOINT |",
                "        MQC.MQGMO_NO_WAIT |",
                "        MQC.MQGMO_CONVERT |",
                "        MQC.MQGMO_FAIL_IF_QUIESCING;",
                "    return new Promise((resolve, reject) => {",
                "        mq.GetSync(queueClient, messageDescriptor, getMessageOptions, buffer, function (err, len) {",
                "            logger.info(messageDescriptor, buffer);",
                "            if (err) {",
                "                reject(err);",
                "                if (err.mqrc == MQC.MQRC_NO_MSG_AVAILABLE) {",
                "                    logger.info('no more messages');",
                "                } else {",
                "                    logger.warn('MQGET failed with ' + err.mqrc);",
                "                }",
                "            } else {",
                "                resolve(Buffer.from(buffer));",
                "                logger.info('Found Message in Queue');",
                "            }",
                "        });",
                "    })",
                "}",
                "const queueClient = await openQueue(connectorData.mqClient, { queue: inputData.queue });",
                "setInterval(async () => {",
                "    const result = await getMessage(queueClient);",
                "    StartProcess({ data: result });",
                "}, 100);"
            ],
            "_lastUpdated": "2024-04-15T18:56:04.638Z",
            "_createdAt": "2024-04-15T18:56:04.638Z",
            "nodeId": "f058446ed8dd3750586fefb981ddd4505da7dbe67ff6f61bee5268876245643c",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbab85",
            "_deleted": false,
            "_version": 15,
            "category": "PROCESS",
            "group": "HTTP",
            "type": "V1_HTTP_CLIENT",
            "connectorType": "HTTP",
            "label": "HTTP Client",
            "icon": "ni ni-http-client",
            "version": 1,
            "inputSchema": [
                {
                    "key": "method",
                    "type": "String"
                },
                {
                    "key": "path",
                    "type": "String"
                },
                {
                    "key": "query",
                    "type": "KeyValPair"
                },
                {
                    "key": "data",
                    "type": "Buffer"
                },
                {
                    "key": "headers",
                    "type": "KeyValPair"
                },
                {
                    "key": "timeout",
                    "type": "Number"
                },
                {
                    "key": "throwErrorOn4xx",
                    "type": "Boolean"
                },
                {
                    "key": "retries",
                    "type": "Number"
                },
                {
                    "key": "retryDelay",
                    "type": "Number"
                }
            ],
            "outputSchema": [
                {
                    "key": "headers",
                    "type": "KeyValPair"
                },
                {
                    "key": "statusCode",
                    "type": "Number"
                },
                {
                    "key": "data",
                    "type": "Buffer"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": "const axios = require('axios');\nconst axiosRetry = require('axios-retry').default;\nconst axiosConfig = {};\ntry {\n    axiosRetry(axios, {\n        retries: inputData.retries || process.env.HTTPCLIENT_RETRIES || 0,\n        retryDelay: (retryCount, error) => {\n            logger.info(`[RETRY] Attempt #${retryCount} - Reason: ${error?.code || error?.message}`);\n            return (inputData.retryDelay || process.env.HTTPCLIENT_RETRY_DELAY || 1000);\n        },\n        onRetry: (retryCount, error, requestConfig) => {\n            logger.error(`[RETRYING] Retry #${retryCount} for ${requestConfig?.url} - Error: ${error?.message}`);\n        },\n        retryCondition: (error) => {\n            // Log the error to understand what's happening\n            logger.info('[DEBUG] Checking retry condition for error:', {\n                status: error?.response?.status,\n                code: error?.code,\n                message: error?.message\n            });\n            // Retry on 401, network errors, and 5xx errors\n            return axiosRetry.isNetworkOrIdempotentRequestError(error) ||\n                (error?.response?.status >= 400 && error?.response?.status <= 599);\n        },\n        shouldResetTimeout: true // Reset the timeout between retries\n    });\n    axiosConfig.responseType = 'arraybuffer';\n    axiosConfig.method = inputData.method;\n    axiosConfig.url = `${connectorData.protocol}://${connectorData.host}:${connectorData.port}${inputData.path}`;\n    axiosConfig.data = inputData.data ? Buffer.from(inputData.data) : undefined;\n    axiosConfig.params = inputData.query;\n    axiosConfig.headers = inputData.headers;\n    axiosConfig.timeout = inputData.timeout || process.env.HTTPCLIENT_TIMEOUT || 60000;\n    logger.info(`Making HTTP [${axiosConfig.method}] Request at [${axiosConfig.url}]`);\n    logger.trace(JSON.stringify(axiosConfig));\n    axiosConfig.validateStatus = function (status) {\n        if (inputData.throwErrorOn4xx) {\n            return status >= 200 && status < 300;\n        } else {\n            return status >= 200 && status < 500;\n        }\n    };\n    let response = await axios(axiosConfig);\n    return { statusCode: response.status, data: response.data, headers: response.headers };\n}\ncatch (err) {\n    if (err.response) {\n        const error = new Error(`Axios request failed: ${err.response.status} - ${err.response.statusText}`);\n        error.statusCode = err.response.status;\n        error.data = err.response.data;\n        error.stack = err.stack;\n        throw error;\n\n    } else if (err.code === 'ECONNABORTED') {\n        const error = new Error('Request timeout');\n        error.statusCode = 408;\n        error.code = err.code;\n        error.stack = err.stack;\n        throw error;\n\n    } else {\n        throw err;\n    }\n}",
            "_lastUpdated": "2025-07-24T09:53:23.131Z",
            "_createdAt": "2024-04-15T18:56:04.638Z",
            "nodeId": "d5de78515e54cbf86368373a000239f1b157de9d5444223606bd322e84687c43",
            "__v": 1,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbab86",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "Database",
            "type": "V1_MYSQL_QUERY",
            "connectorType": "MYSQL",
            "label": "MySQL Query",
            "icon": "ni ni-database-read",
            "version": 1,
            "inputSchema": [
                {
                    "key": "query",
                    "type": "String"
                },
                {
                    "key": "values",
                    "type": "Array",
                    "subType": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Schema"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [
                "const result = await connectorData.mysqlCon.query(inputData.query);",
                "return { data: result[0] };"
            ],
            "_lastUpdated": "2024-04-15T18:56:04.639Z",
            "_createdAt": "2024-04-15T18:56:04.638Z",
            "nodeId": "eeb55ca904cdc4dcbce4f219df9d1af2f5c4d3762eff2ad5941112d785f7851b",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbab8a",
            "_deleted": false,
            "_version": 9,
            "category": "PROCESS",
            "group": "Database",
            "type": "V1_ORACLE_QUERY",
            "connectorType": "ORACLE",
            "label": "ORACLE Query",
            "icon": "ni ni-database-read",
            "version": 1,
            "inputSchema": [
                {
                    "key": "query",
                    "type": "String"
                },
                {
                    "key": "values",
                    "type": "Array",
                    "subType": "String"
                },
                {
                    "key": "queryTimeout",
                    "type": "Number"
                }
            ],
            "outputSchema": [
                {
                    "key": "rows",
                    "type": "Schema"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": "const oracledb = require('oracledb');\nlet connection;\ntry {\n    const queryTimeout = (+(connectorData.queryTimeout || inputData.queryTimeout || 60)) * 1000;\n    connection = await oracledb.getConnection(connectorData.poolName);\n    const queryPromise = connection.execute(inputData.query, (inputData.values || []));\n    const result = await withTimeout(queryPromise, queryTimeout);\n    return { rows: result.rows };\n} catch (err) {\n    throw err\n} finally {\n    if (connection) {\n        connection.close();\n    }\n}\n\nfunction withTimeout(promise, ms) {\n    return Promise.race([\n        promise,\n        new Promise((_, reject) =>\n            setTimeout(() => reject(new Error('Query timeout exceeded: ' + ms + 'ms')), ms)\n        ),\n    ]);\n}",
            "_lastUpdated": "2025-01-15T04:57:23.098Z",
            "_createdAt": "2024-04-15T18:56:04.639Z",
            "nodeId": "c5e5362389e88f49f4a91855b73ff2ce827dd1016a8c2923980523be316f7922",
            "__v": 2,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbab8b",
            "_deleted": false,
            "_version": 7,
            "category": "PROCESS",
            "group": "Database",
            "type": "V1_ORACLE_INSERT",
            "connectorType": "ORACLE",
            "label": "ORACLE Insert",
            "icon": "ni ni-database-write",
            "version": 1,
            "inputSchema": [
                {
                    "key": "query",
                    "type": "String"
                },
                {
                    "key": "values",
                    "subType": "String",
                    "type": "Array"
                }
            ],
            "outputSchema": [
                {
                    "key": "rowsAffected",
                    "type": "Number"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": "const oracledb = require('oracledb');\nlet connection;\ntry {\n    connection = await oracledb.getConnection(connectorData.poolName);\n    const result = await connection.execute(inputData.query, (inputData.values || []));\n    return { rowsAffected: result.rowsAffected };\n} catch (err) {\n    throw err\n} finally {\n    if (connection) {\n        connection.close();\n    }\n}",
            "_lastUpdated": "2024-09-03T06:18:46.344Z",
            "_createdAt": "2024-04-15T18:56:04.639Z",
            "nodeId": "ebc30f7f127867652f1d498dea01bad38b58a3ee964083b5707531a260281e05",
            "__v": 1,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbab89",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "Database",
            "type": "V1_MYSQL_DELETE",
            "connectorType": "MYSQL",
            "label": "MySQL Delete",
            "icon": "ni ni-database-delete",
            "version": 1,
            "inputSchema": [
                {
                    "key": "query",
                    "type": "String"
                },
                {
                    "key": "values",
                    "type": "Array",
                    "subType": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "deletedCount",
                    "type": "Number"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [
                "const result = await connectorData.mysqlCon.query(inputData.query);",
                "return { deletedCount: result[0].affectedRows };"
            ],
            "_lastUpdated": "2024-04-15T18:56:04.639Z",
            "_createdAt": "2024-04-15T18:56:04.639Z",
            "nodeId": "9806a14e8ea9fc7585045cd20f8e4a4022ca233b449927b72562a06af00319b7",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbab8c",
            "_deleted": false,
            "_version": 8,
            "category": "PROCESS",
            "group": "Database",
            "type": "V1_ORACLE_UPDATE",
            "connectorType": "ORACLE",
            "label": "ORACLE Update",
            "icon": "ni ni-database-update",
            "version": 1,
            "inputSchema": [
                {
                    "key": "query",
                    "type": "String"
                },
                {
                    "key": "values",
                    "type": "Array",
                    "subType": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "rowsAffected",
                    "type": "Number"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": "const oracledb = require('oracledb');\nlet connection;\ntry {\n    connection = await oracledb.getConnection(connectorData.poolName);\n    const result = await connection.execute(inputData.query, (inputData.values || []));\n    return { rowsAffected: result.rowsAffected };\n} catch (err) {\n    throw err\n} finally {\n    if (connection) {\n        connection.close();\n    }\n}",
            "_lastUpdated": "2024-09-03T06:19:11.776Z",
            "_createdAt": "2024-04-15T18:56:04.639Z",
            "nodeId": "63973dfb878f7e2bada7c006511d920a12eb94523bdfb05ebd5dc3ce4b60a2ac",
            "__v": 1,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbab8d",
            "_deleted": false,
            "_version": 7,
            "category": "PROCESS",
            "group": "Database",
            "type": "V1_ORACLE_DELETE",
            "connectorType": "ORACLE",
            "label": "ORACLE Delete",
            "icon": "ni ni-database-delete",
            "version": 1,
            "inputSchema": [
                {
                    "key": "query",
                    "type": "String"
                },
                {
                    "key": "values",
                    "subType": "String",
                    "type": "Array"
                }
            ],
            "outputSchema": [
                {
                    "key": "rowsAffected",
                    "type": "Number"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": "const oracledb = require('oracledb');\nlet connection;\ntry {\n    connection = await oracledb.getConnection(connectorData.poolName);\n    const result = await connection.execute(inputData.query, (inputData.values || []));\n    return { rowsAffected: result.rowsAffected };\n} catch (err) {\n    throw err\n} finally {\n    if (connection) {\n        connection.close();\n    }\n}",
            "_lastUpdated": "2024-09-03T06:19:36.787Z",
            "_createdAt": "2024-04-15T18:56:04.639Z",
            "nodeId": "8c902a1f3da7060f8fea177540e6e66e3a9237e45957d926412490c9f29d30d1",
            "__v": 1,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbab8f",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "Database",
            "type": "V1_MSSQL_INSERT",
            "connectorType": "MSSQL",
            "label": "MSSQL Insert",
            "icon": "ni ni-database-write",
            "version": 1,
            "inputSchema": [
                {
                    "key": "query",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "insertedCount",
                    "type": "Number"
                },
                {
                    "key": "insertedIds",
                    "type": "Array",
                    "subType": "String"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [],
            "_lastUpdated": "2024-04-15T18:56:04.639Z",
            "_createdAt": "2024-04-15T18:56:04.639Z",
            "nodeId": "ab557559cbe514eeb6e8d28edd6fb2768ab6bb0ff9971c78d13c3a4e0d6d6c24",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbab8e",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "Database",
            "type": "V1_MSSQL_QUERY",
            "connectorType": "MSSQL",
            "label": "MSSQL Query",
            "icon": "ni ni-database-read",
            "version": 1,
            "inputSchema": [
                {
                    "key": "query",
                    "type": "String"
                },
                {
                    "key": "values",
                    "type": "Array",
                    "subType": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Schema"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [],
            "_lastUpdated": "2024-04-15T18:56:04.639Z",
            "_createdAt": "2024-04-15T18:56:04.639Z",
            "nodeId": "815f659f7a37d527efc203c69f7cf0b468cb9e585e25468ca64c999c2b07a077",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbab90",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "Database",
            "type": "V1_MSSQL_UPDATE",
            "connectorType": "MSSQL",
            "label": "MSSQL Update",
            "icon": "ni ni-database-update",
            "version": 1,
            "inputSchema": [
                {
                    "key": "query",
                    "type": "String"
                },
                {
                    "key": "values",
                    "subType": "String",
                    "type": "Array"
                }
            ],
            "outputSchema": [
                {
                    "key": "matchedCount",
                    "type": "Number"
                },
                {
                    "key": "modifiedCount",
                    "type": "Number"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [],
            "_lastUpdated": "2024-04-15T18:56:04.639Z",
            "_createdAt": "2024-04-15T18:56:04.639Z",
            "nodeId": "df855c857ff25abdedc796ff694b64efc775d7555af99aab2e97a9e790410e78",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbab91",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "Database",
            "type": "V1_MSSQL_DELETE",
            "connectorType": "MSSQL",
            "label": "MSSQL Delete",
            "icon": "ni ni-database-delete",
            "version": 1,
            "inputSchema": [
                {
                    "key": "queryv",
                    "type": "String"
                },
                {
                    "key": "values",
                    "subType": "String",
                    "type": "Array"
                }
            ],
            "outputSchema": [
                {
                    "key": "deletedCount",
                    "type": "Number"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [],
            "_lastUpdated": "2024-04-15T18:56:04.639Z",
            "_createdAt": "2024-04-15T18:56:04.639Z",
            "nodeId": "f51f402b17a4753369599cff72d5c7db4336ad16ef59cb3af124b6891519b39d",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbab92",
            "_deleted": false,
            "_version": 7,
            "category": "PROCESS",
            "group": "Database",
            "type": "V1_POSTGRE_QUERY",
            "connectorType": "PGSQL",
            "label": "Postgre Query",
            "icon": "ni ni-database-read",
            "version": 1,
            "inputSchema": [
                {
                    "key": "query",
                    "type": "String"
                },
                {
                    "key": "values",
                    "type": "Array",
                    "schema": [
                        {}
                    ],
                    "subType": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Schema"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": "const client = await connectorData.pgPool.connect();\ntry {\n    const result = await client.query(inputData.query, inputData.values);\n    return { data: result.rows };\n} finally {\n    client.release();\n}",
            "_lastUpdated": "2025-03-10T12:38:27.024Z",
            "_createdAt": "2024-04-15T18:56:04.639Z",
            "nodeId": "bfba4bfc9e791e6395d93ef36b0ddf446ac42df5af76fe7eef61bfbb880d9ae8",
            "__v": 2,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbab93",
            "_deleted": false,
            "_version": 3,
            "category": "PROCESS",
            "group": "Database",
            "type": "V1_POSTGRE_INSERT",
            "connectorType": "PGSQL",
            "label": "Postgre Insert",
            "icon": "ni ni-database-write",
            "version": 1,
            "inputSchema": [
                {
                    "key": "query",
                    "type": "String"
                },
                {
                    "key": "values",
                    "subType": "String",
                    "type": "Array"
                }
            ],
            "outputSchema": [
                {
                    "key": "insertedCount",
                    "type": "Number"
                },
                {
                    "key": "insertedIds",
                    "type": "Array",
                    "subType": "String"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": "const client = await connectorData.pgPool.connect();\ntry {\n    const result = await client.query(inputData.query.inputData.values);\n    return {\n        insertedCount: result.rowCount,\n        insertedIds: result.rows.map(e => e.id)\n    };\n} finally {\n    client.release();\n}",
            "_lastUpdated": "2025-03-10T07:16:38.304Z",
            "_createdAt": "2024-04-15T18:56:04.639Z",
            "nodeId": "19bce773035e6448835648c18cb5df351df8ec3772bb597b0f2a428257ab3fdb",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbab94",
            "_deleted": false,
            "_version": 3,
            "category": "PROCESS",
            "group": "Database",
            "type": "V1_POSTGRE_UPDATE",
            "connectorType": "PGSQL",
            "label": "Postgre Update",
            "icon": "ni ni-database-update",
            "version": 1,
            "inputSchema": [
                {
                    "key": "query",
                    "type": "String"
                },
                {
                    "key": "values",
                    "subType": "String",
                    "type": "Array"
                }
            ],
            "outputSchema": [
                {
                    "key": "matchedCount",
                    "type": "Number"
                },
                {
                    "key": "modifiedCount",
                    "type": "Number"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": "const client = await connectorData.pgPool.connect();\ntry {\n    const result = await client.query(inputData.query.inputData.values);\n    return {\n        modifiedCount: result.rowCount\n    };\n} finally {\n    client.release();\n}",
            "_lastUpdated": "2025-03-10T07:16:56.092Z",
            "_createdAt": "2024-04-15T18:56:04.639Z",
            "nodeId": "d05e6801b74697809d494e3d381fd834df76302fb953b8886391206f5f72e78c",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbab95",
            "_deleted": false,
            "_version": 3,
            "category": "PROCESS",
            "group": "Database",
            "type": "V1_POSTGRE_DELETE",
            "connectorType": "PGSQL",
            "label": "Postgre Delete",
            "icon": "ni ni-database-delete",
            "version": 1,
            "inputSchema": [
                {
                    "key": "query",
                    "type": "String"
                },
                {
                    "key": "values",
                    "subType": "String",
                    "type": "Array"
                }
            ],
            "outputSchema": [
                {
                    "key": "deletedCount",
                    "type": "Number"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": "const client = await connectorData.pgPool.connect();\ntry {\n    const result = await client.query(inputData.query.inputData.values);\n    return {\n        deletedCount: result.rowCount\n    };\n} finally {\n    client.release();\n}",
            "_lastUpdated": "2025-03-10T07:17:12.668Z",
            "_createdAt": "2024-04-15T18:56:04.639Z",
            "nodeId": "0203e04e41325eed72020cfa9927055623dfad1ff87cd328e111cf151dd135f9",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbab96",
            "_deleted": false,
            "_version": 3,
            "category": "PROCESS",
            "group": "Database",
            "type": "V1_MONGODB_FIND_MANY",
            "connectorType": "MONGODB",
            "label": "MongoDB Find Many",
            "icon": "ni ni-database-read",
            "version": 1,
            "inputSchema": [
                {
                    "key": "filter",
                    "type": "KeyValPair"
                },
                {
                    "key": "project",
                    "type": "KeyValPair"
                },
                {
                    "key": "sort",
                    "type": "KeyValPair"
                },
                {
                    "key": "limit",
                    "type": "Number"
                },
                {
                    "key": "offset",
                    "type": "Number"
                },
                {
                    "key": "timeout",
                    "type": "Number"
                },
                {
                    "key": "collection",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Schema"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": "const cursor = connectorData.db.collection(inputData.collection).find(inputData.filter);\nif (!_.isEmpty(inputData.project)) {\n    cursor.project(inputData.project);\n}\nif (!_.isEmpty(inputData.sort)) {\n    cursor.sort(inputData.sort);\n}\nif (inputData.offset) {\n    cursor.skip(inputData.offset);\n}\nif (inputData.limit) {\n    cursor.limit(inputData.limit);\n}\nconst result = await cursor.toArray();\nreturn { data: result };",
            "_lastUpdated": "2025-02-07T09:17:07.115Z",
            "_createdAt": "2024-04-15T18:56:04.639Z",
            "nodeId": "a92bf380473fbb71b71aca6f1d86a20ab2b5c419052ffb6d71f56571c126bd62",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbab97",
            "_deleted": false,
            "_version": 3,
            "category": "PROCESS",
            "group": "Database",
            "type": "V1_MONGODB_INSERT_MANY",
            "connectorType": "MONGODB",
            "label": "MongoDB Insert Many",
            "icon": "ni ni-database-write",
            "version": 1,
            "inputSchema": [
                {
                    "key": "data",
                    "type": "Schema"
                },
                {
                    "key": "collection",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "insertedCount",
                    "type": "Number"
                },
                {
                    "key": "insertedIds",
                    "type": "Array",
                    "subType": "String"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": "const result = await connectorData.db.collection(inputData.collection).insertMany(inputData.data);\nreturn result;",
            "_lastUpdated": "2025-02-07T09:17:18.251Z",
            "_createdAt": "2024-04-15T18:56:04.639Z",
            "nodeId": "c1184f25d72eb924b19375381725cb93d404877352a90407c4aa4f5817f2df1a",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbab98",
            "_deleted": false,
            "_version": 3,
            "category": "PROCESS",
            "group": "Database",
            "type": "V1_MONGODB_UPDATE_MANY",
            "connectorType": "MONGODB",
            "label": "MongoDB Update Many",
            "icon": "ni ni-database-update",
            "version": 1,
            "inputSchema": [
                {
                    "key": "filter",
                    "type": "KeyValPair"
                },
                {
                    "key": "data",
                    "type": "Schema"
                },
                {
                    "key": "collection",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "matchedCount",
                    "type": "Number"
                },
                {
                    "key": "modifiedCount",
                    "type": "Number"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": "const result = await connectorData.db.collection(inputData.collection).updateMany(inputData.filter, inputData.data);\nreturn result;",
            "_lastUpdated": "2025-02-07T09:17:26.158Z",
            "_createdAt": "2024-04-15T18:56:04.639Z",
            "nodeId": "f122632dc172f9eaa2223c9b299efe3cd073cd92b9e37d71b54558992b40f3a6",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbab99",
            "_deleted": false,
            "_version": 3,
            "category": "PROCESS",
            "group": "Database",
            "type": "V1_MONGODB_DELETE_MANY",
            "connectorType": "MONGODB",
            "label": "MongoDB Delete Many",
            "icon": "ni ni-database-delete",
            "version": 1,
            "inputSchema": [
                {
                    "key": "filter",
                    "type": "KeyValPair"
                },
                {
                    "key": "collection",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "deletedCount",
                    "type": "Number"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": "const result = await connectorData.db.collection(inputData.collection).deleteMany(inputData.filter);\nreturn result;",
            "_lastUpdated": "2025-02-07T09:17:33.959Z",
            "_createdAt": "2024-04-15T18:56:04.639Z",
            "nodeId": "c0e6cc9083464053fb4bbb1ee8e68d99cdeebe6b7c21bfee2f5642da4a8c2588",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbab9a",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "Database",
            "type": "V1_DOCUMENTDB_FIND_MANY",
            "connectorType": "DOCUMENTDB",
            "label": "DocumentDB Find Many",
            "icon": "ni ni-database-read",
            "version": 1,
            "inputSchema": [
                {
                    "key": "filter",
                    "type": "KeyValPair"
                },
                {
                    "key": "project",
                    "type": "KeyValPair"
                },
                {
                    "key": "sort",
                    "type": "KeyValPair"
                },
                {
                    "key": "limit",
                    "type": "Number"
                },
                {
                    "key": "offset",
                    "type": "Number"
                },
                {
                    "key": "timeout",
                    "type": "Number"
                },
                {
                    "key": "collection",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Schema"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [
                "const cursor = connectorData.collection.find(inputData.filter);",
                "if (!_.isEmpty(inputData.project)) {",
                "    cursor.project(inputData.project);",
                "}",
                "if (!_.isEmpty(inputData.sort)) {",
                "    cursor.sort(inputData.sort);",
                "}",
                "if (inputData.offset) {",
                "    cursor.skip(inputData.offset);",
                "}",
                "if (inputData.limit) {",
                "    cursor.limit(inputData.limit);",
                "}",
                "const result = await cursor.toArray();",
                "return { data: result };"
            ],
            "_lastUpdated": "2024-04-15T18:56:04.639Z",
            "_createdAt": "2024-04-15T18:56:04.639Z",
            "nodeId": "9c135d02b4d9b11b15a745671c6e582eb4e580e77e213dbc85b1bfae35665e18",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbab87",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "Database",
            "type": "V1_MYSQL_INSERT",
            "connectorType": "MYSQL",
            "label": "MySQL Insert",
            "icon": "ni ni-database-write",
            "version": 1,
            "inputSchema": [
                {
                    "key": "query",
                    "type": "String"
                },
                {
                    "key": "values",
                    "subType": "String",
                    "type": "Array"
                }
            ],
            "outputSchema": [
                {
                    "key": "insertedCount",
                    "type": "Number"
                },
                {
                    "key": "insertedIds",
                    "type": "Array",
                    "subType": "String"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [
                "const result = await connectorData.mysqlCon.query(inputData.query);",
                "return { insertedCount: result[0].affectedRows };"
            ],
            "_lastUpdated": "2024-04-15T18:56:04.639Z",
            "_createdAt": "2024-04-15T18:56:04.639Z",
            "nodeId": "29798ef8b28177e40e641ac4ac23b2002230de2247237ded6913ac0d932f9203",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbab88",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "Database",
            "type": "V1_MYSQL_UPDATE",
            "connectorType": "MYSQL",
            "label": "MySQL Update",
            "icon": "ni ni-database-update",
            "version": 1,
            "inputSchema": [
                {
                    "key": "query",
                    "type": "String"
                },
                {
                    "key": "values",
                    "subType": "String",
                    "type": "Array"
                }
            ],
            "outputSchema": [
                {
                    "key": "matchedCount",
                    "type": "Number"
                },
                {
                    "key": "modifiedCount",
                    "type": "Number"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [
                "const result = await connectorData.mysqlCon.query(inputData.query);",
                "return { modifiedCount: result[0].affectedRows };"
            ],
            "_lastUpdated": "2024-04-15T18:56:04.639Z",
            "_createdAt": "2024-04-15T18:56:04.639Z",
            "nodeId": "a8e67ebd3adc019bca59dbabc5e89989ee72c3c0f7a2f809c224631c850d67db",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbab9d",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "Database",
            "type": "V1_DOCUMENTDB_DELETE_MANY",
            "connectorType": "DOCUMENTDB",
            "label": "DocumentDB Delete Many",
            "icon": "ni ni-database-delete",
            "version": 1,
            "inputSchema": [
                {
                    "key": "filter",
                    "type": "KeyValPair"
                },
                {
                    "key": "collection",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "deletedCount",
                    "type": "Number"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [
                "const result = await connectorData.collection.deleteMany(inputData.filter);",
                "return result;"
            ],
            "_lastUpdated": "2024-04-15T18:56:04.639Z",
            "_createdAt": "2024-04-15T18:56:04.639Z",
            "nodeId": "7f2c73eaddaa457558dd68c3dde8600cb930780794f7c380bbb2c92108ffadd1",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbab9e",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "Database",
            "type": "V1_COSMOSDB_FIND_MANY",
            "connectorType": "COSMOSDB",
            "label": "CosmosDB Find Many",
            "icon": "ni ni-database-read",
            "version": 1,
            "inputSchema": [
                {
                    "key": "filter",
                    "type": "KeyValPair"
                },
                {
                    "key": "project",
                    "type": "KeyValPair"
                },
                {
                    "key": "sort",
                    "type": "KeyValPair"
                },
                {
                    "key": "limit",
                    "type": "Number"
                },
                {
                    "key": "offset",
                    "type": "Number"
                },
                {
                    "key": "timeout",
                    "type": "Number"
                },
                {
                    "key": "collection",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Schema"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [
                "const cursor = connectorData.collection.find(inputData.filter);",
                "if (!_.isEmpty(inputData.project)) {",
                "    cursor.project(inputData.project);",
                "}",
                "if (!_.isEmpty(inputData.sort)) {",
                "    cursor.sort(inputData.sort);",
                "}",
                "if (inputData.offset) {",
                "    cursor.skip(inputData.offset);",
                "}",
                "if (inputData.limit) {",
                "    cursor.limit(inputData.limit);",
                "}",
                "const result = await cursor.toArray();",
                "return { data: result };"
            ],
            "_lastUpdated": "2024-04-15T18:56:04.640Z",
            "_createdAt": "2024-04-15T18:56:04.639Z",
            "nodeId": "72ca35218b00ef007bf74160306ac3f45802e30ee0b22909088851307eac31d8",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbab9f",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "Database",
            "type": "V1_COSMOSDB_INSERT_MANY",
            "connectorType": "COSMOSDB",
            "label": "CosmosDB Insert Many",
            "icon": "ni ni-database-write",
            "version": 1,
            "inputSchema": [
                {
                    "key": "data",
                    "type": "Schema"
                },
                {
                    "key": "collection",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "insertedCount",
                    "type": "Number"
                },
                {
                    "key": "insertedIds",
                    "type": "Array",
                    "subType": "String"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [
                "const result = await connectorData.collection.insertMany(inputData.data);",
                "return result;"
            ],
            "_lastUpdated": "2024-04-15T18:56:04.640Z",
            "_createdAt": "2024-04-15T18:56:04.640Z",
            "nodeId": "aca6da218843908ced1c144398439518fc6eda6d52430669cfd589c1e270dec2",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbaba0",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "Database",
            "type": "V1_COSMOSDB_UPDATE_MANY",
            "connectorType": "COSMOSDB",
            "label": "CosmosDB Update Many",
            "icon": "ni ni-database-update",
            "version": 1,
            "inputSchema": [
                {
                    "key": "filter",
                    "type": "KeyValPair"
                },
                {
                    "key": "data",
                    "type": "Schema"
                },
                {
                    "key": "collection",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "matchedCount",
                    "type": "Number"
                },
                {
                    "key": "modifiedCount",
                    "type": "Number"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [
                "const result = await connectorData.collection.updateMany(inputData.filter, inputData.data);",
                "return result;"
            ],
            "_lastUpdated": "2024-04-15T18:56:04.640Z",
            "_createdAt": "2024-04-15T18:56:04.640Z",
            "nodeId": "38c748798bbe925febf39db5c364e657465890ab8dbc1211e8d3434837504fbb",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbaba1",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "Database",
            "type": "V1_COSMOSDB_DELETE_MANY",
            "connectorType": "COSMOSDB",
            "label": "CosmosDB Delete Many",
            "icon": "ni ni-database-delete",
            "version": 1,
            "inputSchema": [
                {
                    "key": "filter",
                    "type": "KeyValPair"
                },
                {
                    "key": "collection",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "deletedCount",
                    "type": "Number"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [
                "const result = await connectorData.collection.deleteMany(inputData.filter);",
                "return result;"
            ],
            "_lastUpdated": "2024-04-15T18:56:04.640Z",
            "_createdAt": "2024-04-15T18:56:04.640Z",
            "nodeId": "0f069a630fe9c2fdb1b2a9028591af4ba4b8aa505af01beb4d521d5135be3287",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbaba2",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "File",
            "type": "V1_SFTP_LIST",
            "connectorType": "SFTP",
            "label": "SFTP List",
            "icon": "ni ni-sftp-ls",
            "version": 1,
            "inputSchema": [
                {
                    "key": "folderPath",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Array",
                    "subType": "Object",
                    "schema": [
                        {
                            "key": "type",
                            "type": "String"
                        },
                        {
                            "key": "name",
                            "type": "String"
                        },
                        {
                            "key": "size",
                            "type": "Number"
                        },
                        {
                            "key": "modifyTime",
                            "type": "Number"
                        }
                    ]
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [
                "if (!inputData.folderPath) {",
                "    throw new Error('No Directory Path provided');",
                "}",
                "const fileList = await connectorData.sftpCon.list(inputData.folderPath);",
                "logger.info('Files in SFTP folder ', fileList.length);",
                "logger.debug(JSON.stringify(fileList));",
                "req.logger.info('Files in SFTP folder ', fileList.length);",
                "req.logger.debug(JSON.stringify(fileList));",
                "return { data: fileList };"
            ],
            "_lastUpdated": "2024-04-15T18:56:04.640Z",
            "_createdAt": "2024-04-15T18:56:04.640Z",
            "nodeId": "8dbaaefcdff662e222591c8e93a20eaced07828dfe7ee913ac000cb59b9a5586",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbaba3",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "File",
            "type": "V1_SFTP_GET",
            "connectorType": "SFTP",
            "label": "SFTP Get",
            "icon": "ni ni-sftp-read",
            "version": 1,
            "inputSchema": [
                {
                    "key": "filePath",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [
                "if (!inputData.filePath) {",
                "    throw new Error('No File Path provided');",
                "}",
                "const data = await connectorData.sftpCon.get(inputData.filePath);",
                "if (data && !_.isEmpty(data)) {",
                "    logger.info('File Found of Size :', data.length);",
                "    req.logger.info('File Found of Size :', data.length);",
                "    return { data };",
                "} else {",
                "    throw Error('File Not Found');",
                "}"
            ],
            "_lastUpdated": "2024-04-15T18:56:04.640Z",
            "_createdAt": "2024-04-15T18:56:04.640Z",
            "nodeId": "ad65f90bd4a8815d7bbeafc6fb59badbd3f37e5093ad7c2f262ecc73ef245df5",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbaba4",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "File",
            "type": "V1_SFTP_PUT",
            "connectorType": "SFTP",
            "label": "SFTP Put",
            "icon": "ni ni-sftp-write",
            "version": 1,
            "inputSchema": [
                {
                    "key": "filePath",
                    "type": "String"
                },
                {
                    "key": "data",
                    "type": "Buffer"
                }
            ],
            "outputSchema": [
                {
                    "key": "statusCode",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [
                "if (!inputData.filePath) {",
                "    throw new Error('No File Path provided');",
                "}",
                "const result = await connectorData.sftpCon.put(inputData.data, inputData.filePath);",
                "if (result && !_.isEmpty(result)) {",
                "    logger.info('File Uploaded :', result);",
                "    req.logger.info('File Uploaded :', result);",
                "    return { statusCode: 200, message: result };",
                "} else {",
                "    throw Error('File Could Not be Placed');",
                "}"
            ],
            "_lastUpdated": "2024-04-15T18:56:04.640Z",
            "_createdAt": "2024-04-15T18:56:04.640Z",
            "nodeId": "409a62e605c88e91da694be13d49432c69404523e225f49d84570b37f2f0f57a",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbaba5",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "File",
            "type": "V1_SFTP_RENAME",
            "connectorType": "SFTP",
            "label": "SFTP Rename",
            "icon": "ni ni-sftp-mv",
            "version": 1,
            "inputSchema": [
                {
                    "key": "sourceFilePath",
                    "type": "String"
                },
                {
                    "key": "targetFilePath",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "statusCode",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [
                "const result = await connectorData.sftpCon.rename(inputData.sourceFilePath, inputData.targetFilePath);",
                "if (result && !_.isEmpty(result)) {",
                "    logger.info('File Renamed :', result);",
                "    req.logger.info('File Renamed :', result);",
                "    return { statusCode: 200, message: result };",
                "} else {",
                "    throw Error('File Could not be Renamed');",
                "}"
            ],
            "_lastUpdated": "2024-04-15T18:56:04.640Z",
            "_createdAt": "2024-04-15T18:56:04.640Z",
            "nodeId": "6b27f6c706d73920c80a34a34ab70480579850d3ade3dbc8d8e909a21c25aae4",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbaba6",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "File",
            "type": "V1_SFTP_DELETE",
            "connectorType": "SFTP",
            "label": "SFTP Delete",
            "icon": "ni ni-sftp-rm",
            "version": 1,
            "inputSchema": [
                {
                    "key": "filePath",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "statusCode",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [
                "if (!inputData.filePath) {",
                "    throw new Error('No File Path provided');",
                "}",
                "const result = await connectorData.sftpCon.delete(inputData.filePath);",
                "if (result && !_.isEmpty(result)) {",
                "    logger.info('File Deleted :', result);",
                "    req.logger.info('File Deleted :', result);",
                "    return { statusCode: 200, message: result };",
                "} else {",
                "    throw Error('File Could Not be Deleted');",
                "}"
            ],
            "_lastUpdated": "2024-04-15T18:56:04.640Z",
            "_createdAt": "2024-04-15T18:56:04.640Z",
            "nodeId": "143cef4b12d0041846582f2d62f1afde18c97e50ca90f395f3d41e6472d2710f",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbaba7",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "File",
            "type": "V1_DISK_LIST",
            "connectorType": "DISK",
            "label": "Disk List",
            "icon": "ni ni-disk-ls",
            "version": 1,
            "inputSchema": [
                {
                    "key": "folderPath",
                    "type": "String"
                },
                {
                    "key": "timeout",
                    "type": "Number"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Array",
                    "subType": "Object",
                    "schema": [
                        {
                            "key": "type",
                            "type": "String"
                        },
                        {
                            "key": "name",
                            "type": "String"
                        },
                        {
                            "key": "size",
                            "type": "Number"
                        },
                        {
                            "key": "modifyTime",
                            "type": "Number"
                        }
                    ]
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [
                "const directoryPath = path.resolve(connectorData.containerPath, inputData.folderPath);",
                "const files = fs.readdirSync(directoryPath);",
                "const result = [];",
                "files.forEach((file) => {",
                "    let fileObj = {};",
                "    const filePath = `${directoryPath}/${file}`;",
                "    const stats = fs.statSync(filePath);",
                "    fileObj.name = file;",
                "    fileObj.size = stats.size;",
                "    fileObj.modifyTime = stats.mtime.getTime();",
                "    fileObj.type = stats.isFile() ? '-' : (stats.isDirectory() ? 'd' : 'l')",
                "    result.push(fileObj);",
                "});",
                "return { data: result };"
            ],
            "_lastUpdated": "2024-04-15T18:56:04.640Z",
            "_createdAt": "2024-04-15T18:56:04.640Z",
            "nodeId": "fbf953024aa018893e736e9cc72e519852209c1bae4033a196556c11d3eb60d2",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbaba8",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "File",
            "type": "V1_DISK_GET",
            "connectorType": "DISK",
            "label": "Disk Get",
            "icon": "ni ni-disk-read",
            "version": 1,
            "inputSchema": [
                {
                    "key": "filePath",
                    "type": "String"
                },
                {
                    "key": "timeout",
                    "type": "Number"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [
                "const directoryPath = path.resolve(connectorData.containerPath, inputData.filePath);",
                "const content = fs.readFileSync(directoryPath);",
                "return { data: content };"
            ],
            "_lastUpdated": "2024-04-15T18:56:04.640Z",
            "_createdAt": "2024-04-15T18:56:04.640Z",
            "nodeId": "889480d90d4be73636b06b07c4f9fa3dfca166d51d4c54190404f40641f04030",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbaba9",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "File",
            "type": "V1_DISK_PUT",
            "connectorType": "DISK",
            "label": "Disk Put",
            "icon": "ni ni-disk-write",
            "version": 1,
            "inputSchema": [
                {
                    "key": "filePath",
                    "type": "String"
                },
                {
                    "key": "data",
                    "type": "Buffer"
                }
            ],
            "outputSchema": [
                {
                    "key": "statusCode",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [
                "const directoryPath = path.resolve(connectorData.containerPath, inputData.filePath);",
                "fs.writeFileSync(directoryPath, inputData.data);",
                "return { statusCode: 200, message: \"File Written Successfully\" };"
            ],
            "_lastUpdated": "2024-04-15T18:56:04.640Z",
            "_createdAt": "2024-04-15T18:56:04.640Z",
            "nodeId": "e3ded9b2404aad383207317c9e733d74a9e4c7a955bc8027a3a4a46206af9a6c",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbabaa",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "File",
            "type": "V1_DISK_RENAME",
            "connectorType": "DISK",
            "label": "Disk Rename",
            "icon": "ni ni-disk-mv",
            "version": 1,
            "inputSchema": [
                {
                    "key": "sourceFilePath",
                    "type": "String"
                },
                {
                    "key": "targetFilePath",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "statusCode",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [
                "const sourceDirectoryPath = path.resolve(connectorData.containerPath, inputData.sourceFilePath);",
                "const targetDirectoryPath = path.resolve(connectorData.containerPath, inputData.targetFilePath);",
                "fs.renameSync(sourceDirectoryPath, targetDirectoryPath);",
                "return { statusCode: 200, message: \"File Renamed Successfully\" };"
            ],
            "_lastUpdated": "2024-04-15T18:56:04.640Z",
            "_createdAt": "2024-04-15T18:56:04.640Z",
            "nodeId": "40fdeca120eee2907c5969ef5c30cb0e0ef32c9f2f0ae3178bc8dd41d351f634",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbabab",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "File",
            "type": "V1_DISK_DELETE",
            "connectorType": "DISK",
            "label": "Disk Delete",
            "icon": "ni ni-disk-rm",
            "version": 1,
            "inputSchema": [
                {
                    "key": "filePath",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "statusCode",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [
                "const directoryPath = path.resolve(connectorData.containerPath, inputData.filePath);",
                "fs.rmSync(directoryPath);",
                "return { statusCode: 200, message: \"File Deleted Successfully\" };"
            ],
            "_lastUpdated": "2024-04-15T18:56:04.640Z",
            "_createdAt": "2024-04-15T18:56:04.640Z",
            "nodeId": "d13b2f4760886f75830d55641cdd1516d041677e61c865a3228af75fb7dab604",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbabac",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "Blob",
            "type": "V1_AZBLOB_LIST",
            "connectorType": "AZBLOB",
            "label": "Azure Blob List",
            "icon": "ni ni-blob-ls",
            "version": 1,
            "inputSchema": [
                {
                    "key": "folderPath",
                    "type": "String"
                },
                {
                    "key": "timeout",
                    "type": "Number"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Array",
                    "subType": "Object",
                    "schema": [
                        {
                            "key": "type",
                            "type": "String"
                        },
                        {
                            "key": "name",
                            "type": "String"
                        },
                        {
                            "key": "size",
                            "type": "Number"
                        },
                        {
                            "key": "modifyTime",
                            "type": "Number"
                        }
                    ]
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [
                "const blobs = connectorData.containerClient.listBlobsFlat({ prefix: inputData.folderPath });",
                "const results = [];",
                "for await (let blob of blobs) {",
                "    const temp = {};",
                "    temp.type = '-';",
                "    temp.modifyTime = new Date(blob.properties.lastModified).getTime();",
                "    temp.name = blob.name;",
                "    temp.size = blob.properties.contentLength;",
                "    results.push(temp);",
                "}",
                "return { data: results };"
            ],
            "_lastUpdated": "2024-04-15T18:56:04.640Z",
            "_createdAt": "2024-04-15T18:56:04.640Z",
            "nodeId": "76f992523080506d0da838e0944867c8cb5a5a0b0b59b4a804088294d5313b13",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbabad",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "Blob",
            "type": "V1_AZBLOB_GET",
            "connectorType": "AZBLOB",
            "label": "Azure Blob Get",
            "icon": "ni ni-blob-read",
            "version": 1,
            "inputSchema": [
                {
                    "key": "blobPath",
                    "type": "String"
                },
                {
                    "key": "timeout",
                    "type": "Number"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                },
                {
                    "key": "metadata",
                    "type": "KeyValPair"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [
                "const blockBlobClient = connectorData.containerClient.getBlockBlobClient(inputData.blobPath);",
                "const result = await blockBlobClient.download();",
                "const bufferData = await commonUtils.getStreamAsBuffer(result.readableStreamBody);",
                "const metadata = result.metadata;",
                "return { data: bufferData, metadata };"
            ],
            "_lastUpdated": "2024-04-15T18:56:04.640Z",
            "_createdAt": "2024-04-15T18:56:04.640Z",
            "nodeId": "569d7694a4fe6bf7a0e2b2533e7381de09bd9eccfb70da61476aeca047659c31",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbabae",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "Blob",
            "type": "V1_AZBLOB_PUT",
            "connectorType": "AZBLOB",
            "label": "Azure Blob Put",
            "icon": "ni ni-blob-write",
            "version": 1,
            "inputSchema": [
                {
                    "key": "blobPath",
                    "type": "String"
                },
                {
                    "key": "data",
                    "type": "Buffer"
                },
                {
                    "key": "metadata",
                    "type": "KeyValPair"
                }
            ],
            "outputSchema": [
                {
                    "key": "statusCode",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "eTag",
                    "type": "String"
                },
                {
                    "key": "requestId",
                    "type": "String"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [
                "const blockBlobClient = connectorData.containerClient.getBlockBlobClient(inputData.blobPath);",
                "const result = await blockBlobClient.uploadData(inputData.data, { metadata: inputData.metadata });",
                "return {",
                "    statusCode: 200,",
                "    message: 'Blob Uploaded',",
                "    eTag: result.etag,",
                "    requestId: result.requestId,",
                "};"
            ],
            "_lastUpdated": "2024-04-15T18:56:04.640Z",
            "_createdAt": "2024-04-15T18:56:04.640Z",
            "nodeId": "26aba05b9d87a805456152886c5ddd6f592a758fd9a48c5494d8f1fe0f520a8a",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbabaf",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "Blob",
            "type": "V1_AZBLOB_DELETE",
            "connectorType": "AZBLOB",
            "label": "Azure Blob Delete",
            "icon": "ni ni-blob-rm",
            "version": 1,
            "inputSchema": [
                {
                    "key": "blobPath",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "statusCode",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "requestId",
                    "type": "String"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [
                "const blockBlobClient = connectorData.containerClient.getBlockBlobClient(inputData.blobPath);",
                "const result = await blockBlobClient.delete();",
                "return {",
                "    statusCode: 200,",
                "    message: 'Blob Deleted',",
                "    requestId: result.requestId,",
                "};"
            ],
            "_lastUpdated": "2024-04-15T18:56:04.640Z",
            "_createdAt": "2024-04-15T18:56:04.640Z",
            "nodeId": "26c7a29fb3b8decb7eea83e6a3b536041e930b12ec7386e2e3edd5a706a4073b",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbabb0",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "Blob",
            "type": "V1_S3_LIST",
            "connectorType": "S3",
            "label": "AWS S3 List",
            "icon": "ni ni-blob-ls",
            "version": 1,
            "inputSchema": [
                {
                    "key": "folderPath",
                    "type": "String"
                },
                {
                    "key": "timeout",
                    "type": "Number"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Array",
                    "subType": "Object",
                    "schema": [
                        {
                            "key": "type",
                            "type": "String"
                        },
                        {
                            "key": "name",
                            "type": "String"
                        },
                        {
                            "key": "size",
                            "type": "Number"
                        },
                        {
                            "key": "modifyTime",
                            "type": "Number"
                        }
                    ]
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [
                "const { ListObjectsCommand } = require('@aws-sdk/client-s3');",
                "const command = new ListObjectsCommand({",
                "    Bucket: connectorData.bucket,",
                "    Prefix: inputData.folderPath",
                "});",
                "const result = await connectorData.s3client.send(command);",
                "const data = result.Contents.map((item) => {",
                "    let temp = {};",
                "    temp.type = '-';",
                "    temp.name = item.Key;",
                "    temp.size = item.Size;",
                "    temp.modifyTime = item.LastModified.getTime();",
                "    return temp;",
                "});",
                "return { data };"
            ],
            "_lastUpdated": "2024-04-15T18:56:04.640Z",
            "_createdAt": "2024-04-15T18:56:04.640Z",
            "nodeId": "d9a71468f80a9ab0e9a4f15d22f8b8167ee1b6ea42f6fc1556d105015099fc6f",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbabb1",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "Blob",
            "type": "V1_S3_GET",
            "connectorType": "S3",
            "label": "AWS S3 Get",
            "icon": "ni ni-blob-read",
            "version": 1,
            "inputSchema": [
                {
                    "key": "blobPath",
                    "type": "String"
                },
                {
                    "key": "timeout",
                    "type": "Number"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                },
                {
                    "key": "metadata",
                    "type": "KeyValPair"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [
                "const { GetObjectCommand } = require('@aws-sdk/client-s3');",
                "const command = new GetObjectCommand({",
                "    Bucket: connectorData.bucket,",
                "    Key: inputData.blobPath",
                "});",
                "const result = await connectorData.s3client.send(command);",
                "const data = await commonUtils.getStreamAsBuffer(result.Body);",
                "return { data, metadata: result.Metadata };"
            ],
            "_lastUpdated": "2024-04-15T18:56:04.640Z",
            "_createdAt": "2024-04-15T18:56:04.640Z",
            "nodeId": "4d4e701e78104f3549e564217f57b853cb08d270247a2d07f04b3242153722f0",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbabb2",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "Blob",
            "type": "V1_S3_PUT",
            "connectorType": "S3",
            "label": "AWS S3 Put",
            "icon": "ni ni-blob-write",
            "version": 1,
            "inputSchema": [
                {
                    "key": "blobPath",
                    "type": "String"
                },
                {
                    "key": "data",
                    "type": "Buffer"
                },
                {
                    "key": "metadata",
                    "type": "KeyValPair"
                }
            ],
            "outputSchema": [
                {
                    "key": "statusCode",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "eTag",
                    "type": "String"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [
                "const { PutObjectCommand } = require('@aws-sdk/client-s3');",
                "const command = new PutObjectCommand({",
                "    Bucket: connectorData.bucket,",
                "    Key: inputData.blobPath,",
                "    Body: inputData.data,",
                "    Metadata: inputData.metadata",
                "});",
                "const result = await connectorData.s3client.send(command);",
                "return { eTag: result.ETag, statusCode: 200, message: 'Object Placed in Bucket' };"
            ],
            "_lastUpdated": "2024-04-15T18:56:04.640Z",
            "_createdAt": "2024-04-15T18:56:04.640Z",
            "nodeId": "8c8a4f0846b21000662b225f2b71dd517c09b6cc8a7012602e66106871a954f2",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbabb3",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "Blob",
            "type": "V1_S3_DELETE",
            "connectorType": "S3",
            "label": "AWS S3 Delete",
            "icon": "ni ni-blob-rm",
            "version": 1,
            "inputSchema": [
                {
                    "key": "blobPath",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "statusCode",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [
                "const { DeleteObjectCommand } = require('@aws-sdk/client-s3');",
                "const command = new DeleteObjectCommand({",
                "    Bucket: connectorData.bucket,",
                "    Key: inputData.blobPath",
                "});",
                "const result = await connectorData.s3client.send(command);",
                "return { statusCode: 200, message: 'Object Deleted from Bucket' };"
            ],
            "_lastUpdated": "2024-04-15T18:56:04.640Z",
            "_createdAt": "2024-04-15T18:56:04.640Z",
            "nodeId": "c1bd03ab1c900600f8d1cc65c9fa0f74de0ff954010dac78ad088e39cbe96df5",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbabb4",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "Blob",
            "type": "V1_GCS_LIST",
            "connectorType": "GCS",
            "label": "Google Blob List",
            "icon": "ni ni-blob-ls",
            "version": 1,
            "inputSchema": [
                {
                    "key": "folderPath",
                    "type": "String"
                },
                {
                    "key": "timeout",
                    "type": "Number"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Array",
                    "schema": [
                        {
                            "key": "type",
                            "type": "String"
                        },
                        {
                            "key": "name",
                            "type": "String"
                        },
                        {
                            "key": "size",
                            "type": "Number"
                        },
                        {
                            "key": "modifyTime",
                            "type": "Number"
                        }
                    ],
                    "subType": "Object"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [
                "let files = await connectorData.gcs.getFiles({ prefix: inputData.folderPath });",
                "let result = files[0].map(e => {",
                "    const temp = {};",
                "    temp.type = '-';",
                "    temp.name = e.metadata.name;",
                "    temp.size = parseInt(e.metadata.size);",
                "    temp.modifyTime = new Date(e.metadata.updated).getTime();",
                "    return temp;",
                "});",
                "return { data: result };"
            ],
            "_lastUpdated": "2024-04-15T18:56:04.640Z",
            "_createdAt": "2024-04-15T18:56:04.640Z",
            "nodeId": "973c55c509516e528547fcd9333fa45b3f96a41e581542f9d74ba89d2c8341e1",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbabb5",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "Blob",
            "type": "V1_GCS_GET",
            "connectorType": "GCS",
            "label": "Google Blob Get",
            "icon": "ni ni-blob-read",
            "version": 1,
            "inputSchema": [
                {
                    "key": "blobPath",
                    "type": "String"
                },
                {
                    "key": "timeout",
                    "type": "Number"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                },
                {
                    "key": "metadata",
                    "type": "KeyValPair"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [
                "let blobFile = connectorData.gcs.file(inputDate.blobPath);",
                "let metadata = await blobFile.getMetadata();",
                "let result = await blobFile.download();",
                "return { metadata, data: result };"
            ],
            "_lastUpdated": "2024-04-15T18:56:04.640Z",
            "_createdAt": "2024-04-15T18:56:04.640Z",
            "nodeId": "3a212f7d81aa104e1cd54b43fec0424b8eefe08b9a4d3bac3a6cb45b381cd8fd",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbabb6",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "Blob",
            "type": "V1_GCS_PUT",
            "connectorType": "GCS",
            "label": "Google Blob Put",
            "icon": "ni ni-blob-write",
            "version": 1,
            "inputSchema": [
                {
                    "key": "blobPath",
                    "type": "String"
                },
                {
                    "key": "data",
                    "type": "Buffer"
                },
                {
                    "key": "metadata",
                    "type": "KeyValPair"
                }
            ],
            "outputSchema": [
                {
                    "key": "statusCode",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [
                "await connectorData.gcs.file(inputDate.blobPath).save(inputDate.data, {",
                "    metadata: {",
                "        metadata: inputDate.metadata",
                "    }",
                "});",
                "return { statusCode: 200, message: 'File Uploaded' };"
            ],
            "_lastUpdated": "2024-04-15T18:56:04.640Z",
            "_createdAt": "2024-04-15T18:56:04.640Z",
            "nodeId": "910c8e643324e7acc4780785bde05b452cbc5ab503ddb2b7fe8e5d759eab5055",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbabb7",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "Blob",
            "type": "V1_GCS_DELETE",
            "connectorType": "GCS",
            "label": "Google Blob Delete",
            "icon": "ni ni-blob-rm",
            "version": 1,
            "inputSchema": [
                {
                    "key": "blobPath",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "statusCode",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [
                "await connectorData.gcs.file(inputDate.blobPath).delete();",
                "return { statusCode: 200, message: 'File Deleted' };"
            ],
            "_lastUpdated": "2024-04-15T18:56:04.641Z",
            "_createdAt": "2024-04-15T18:56:04.640Z",
            "nodeId": "60bc5aa161f8f1cb5d200799470faa0942dff4ea04dd6be15af0867407314856",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbabb8",
            "_deleted": false,
            "_version": 13,
            "category": "PROCESS",
            "group": "DataService",
            "type": "V1_DATASERVICE_COUNT",
            "connectorType": "DATASERVICE",
            "label": "Data Service Count",
            "icon": "ni ni-dataservice",
            "version": 1,
            "inputSchema": [
                {
                    "key": "filter",
                    "type": "String"
                },
                {
                    "key": "timeout",
                    "type": "Number"
                },
                {
                    "key": "token",
                    "type": "String"
                },
                {
                    "key": "retries",
                    "type": "Number"
                },
                {
                    "key": "retryDelay",
                    "type": "Number"
                }
            ],
            "outputSchema": [
                {
                    "key": "statusCode",
                    "type": "Number"
                },
                {
                    "key": "count",
                    "type": "Number"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": "const axios = require('axios');\nconst axiosRetry = require('axios-retry').default;\n\ntry {\n    axiosRetry(axios, {\n        retries: inputData.retries || process.env.DATASERVICE_RETRIES || 0,\n        retryDelay: (retryCount, error) => {\n            logger.info(`[RETRY] Attempt #${retryCount} - Reason: ${error?.code || error?.message}`);\n            return (inputData.retryDelay || process.env.DATASERVICE_RETRY_DELAY || 1000);\n        },\n        onRetry: (retryCount, error, requestConfig) => {\n            logger.error(`[RETRYING] Retry #${retryCount} for ${requestConfig?.url} - Error: ${error?.message}`);\n        },\n        retryCondition: (error) => {\n            // Log the error to understand what's happening\n            logger.info('[DEBUG] Checking retry condition for error:', {\n                status: error?.response?.status,\n                code: error?.code,\n                message: error?.message\n            });\n            // Retry on 401, network errors, and 5xx errors\n            return axiosRetry.isNetworkOrIdempotentRequestError(error) ||\n                (error?.response?.status >= 400 && error?.response?.status <= 599);\n        },\n        shouldResetTimeout: true // Reset the timeout between retries\n    });\n    const resp = await axios({\n        method: 'get',\n        url: connectorData.api + '/utils/count',\n        headers: {\n            'Content-Type': 'application/json',\n            'Authorization': inputData.token,\n        },\n        params: {\n            filter: inputData.filter\n        },\n        timeout: inputData.timeout || process.env.DATASERVICE_TIMEOUT || 60000,\n    });\n    return { statusCode: resp.statusCode || resp.status, count: resp.data };\n} catch (err) {\n    if (err.response) {\n        const error = new Error(`Axios request failed: ${err.response.status} - ${err.response.statusText}`);\n        error.statusCode = err.response.status;\n        error.data = err.response.data;\n        error.stack = err.stack;\n        throw error;\n    } else if (err.code === 'ECONNABORTED') {\n        const error = new Error('Request timeout');\n        error.statusCode = 408;\n        error.code = err.code;\n        error.stack = err.stack;\n        throw error;\n    }\n    else {\n        throw err;\n    }\n}",
            "_lastUpdated": "2025-07-24T10:16:21.326Z",
            "_createdAt": "2024-04-15T18:56:04.641Z",
            "nodeId": "5f62808a5a47754a9efbc6c6ea51177de87bdffb4a2f4c5faeb88ad9d7207c9d",
            "__v": 2,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbabb9",
            "_deleted": false,
            "_version": 20,
            "category": "PROCESS",
            "group": "DataService",
            "type": "V1_DATASERVICE_LIST",
            "connectorType": "DATASERVICE",
            "label": "Data Service List",
            "icon": "ni ni-dataservice",
            "version": 1,
            "inputSchema": [
                {
                    "key": "filter",
                    "type": "String"
                },
                {
                    "key": "sort",
                    "type": "String"
                },
                {
                    "key": "select",
                    "type": "String"
                },
                {
                    "key": "count",
                    "type": "Number"
                },
                {
                    "key": "page",
                    "type": "Number"
                },
                {
                    "key": "token",
                    "type": "String"
                },
                {
                    "key": "retries",
                    "type": "Number"
                },
                {
                    "key": "timeout",
                    "type": "Number"
                },
                {
                    "key": "retryDelay",
                    "type": "Number"
                },
                {
                    "key": "decrypt",
                    "type": "Boolean"
                }
            ],
            "outputSchema": [
                {
                    "key": "statusCode",
                    "type": "Number"
                },
                {
                    "key": "data",
                    "type": "Array",
                    "subType": "DataService"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": "const axios = require('axios');\nconst axiosRetry = require('axios-retry').default;\n\ntry {\n    axiosRetry(axios, {\n        retries: inputData.retries || process.env.DATASERVICE_RETRIES || 0,\n        retryDelay: (retryCount, error) => {\n            logger.info(`[RETRY] Attempt #${retryCount} - Reason: ${error?.code || error?.message}`);\n            return (inputData.retryDelay || process.env.DATASERVICE_RETRY_DELAY || 1000);\n        },\n        onRetry: (retryCount, error, requestConfig) => {\n            logger.error(`[RETRYING] Retry #${retryCount} for ${requestConfig?.url} - Error: ${error?.message}`);\n        },\n        retryCondition: (error) => {\n            // Log the error to understand what's happening\n            logger.info('[DEBUG] Checking retry condition for error:', {\n                status: error?.response?.status,\n                code: error?.code,\n                message: error?.message\n            });\n            // Retry on 401, network errors, and 5xx errors\n            return axiosRetry.isNetworkOrIdempotentRequestError(error) ||\n                (error?.response?.status >= 400 && error?.response?.status <= 599);\n        },\n        shouldResetTimeout: true // Reset the timeout between retries\n    });\n    const resp = await axios({\n        method: 'get',\n        url: connectorData.api,\n        headers: {\n            'Content-Type': 'application/json',\n            'Authorization': inputData.token,\n        },\n        params: {\n            filter: inputData.filter,\n            count: inputData.count,\n            select: inputData.select,\n            sort: inputData.sort,\n            page: inputData.page,\n            decrypt: inputData.decrypt\n        },\n        timeout: inputData.timeout || process.env.DATASERVICE_TIMEOUT || 60000,\n    });\n    return { statusCode: resp.statusCode || resp.status, data: resp.data };\n} catch (err) {\n    if (err.response) {\n        const error = new Error(`Axios request failed: ${err.response.status} - ${err.response.statusText}`);\n        error.statusCode = err.response.status;\n        error.data = err.response.data;\n        error.stack = err.stack;\n        throw error;\n    } else if (err.code === 'ECONNABORTED') {\n        const error = new Error('Request timeout');\n        error.statusCode = 408;\n        error.code = err.code;\n        error.stack = err.stack;\n        throw error;\n    }\n    else {\n        throw err;\n    }\n}",
            "_lastUpdated": "2025-08-14T08:22:45.284Z",
            "_createdAt": "2024-04-15T18:56:04.641Z",
            "nodeId": "1760bc4579cbc73b8ad27212ae1f2029053b34d19605aa2f15e7e55293aea894",
            "__v": 7,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbabba",
            "_deleted": false,
            "_version": 12,
            "category": "PROCESS",
            "group": "DataService",
            "type": "V1_DATASERVICE_GET",
            "connectorType": "DATASERVICE",
            "label": "Data Service Show",
            "icon": "ni ni-dataservice",
            "version": 1,
            "inputSchema": [
                {
                    "key": "filter",
                    "type": "String"
                },
                {
                    "key": "select",
                    "type": "String"
                },
                {
                    "key": "timeout",
                    "type": "Number"
                },
                {
                    "key": "token",
                    "type": "String"
                },
                {
                    "key": "retries",
                    "type": "Number"
                },
                {
                    "key": "retryDelay",
                    "type": "Number"
                },
                {
                    "key": "decrypt",
                    "type": "Boolean"
                }
            ],
            "outputSchema": [
                {
                    "key": "statusCode",
                    "type": "Number"
                },
                {
                    "key": "data",
                    "type": "DataService"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": "const axios = require('axios');\nconst axiosRetry = require('axios-retry').default;\ntry {\n    axiosRetry(axios, {\n        retries: inputData.retries || process.env.DATASERVICE_RETRIES || 0,\n        retryDelay: (retryCount, error) => {\n            logger.info(`[RETRY] Attempt #${retryCount} - Reason: ${error?.code || error?.message}`);\n            return (inputData.retryDelay || process.env.DATASERVICE_RETRY_DELAY || 1000);\n        },\n        onRetry: (retryCount, error, requestConfig) => {\n            logger.error(`[RETRYING] Retry #${retryCount} for ${requestConfig?.url} - Error: ${error?.message}`);\n        },\n        retryCondition: (error) => {\n            // Log the error to understand what's happening\n            logger.info('[DEBUG] Checking retry condition for error:', {\n                status: error?.response?.status,\n                code: error?.code,\n                message: error?.message\n            });\n            // Retry on 401, network errors, and 5xx errors\n            return axiosRetry.isNetworkOrIdempotentRequestError(error) ||\n                (error?.response?.status >= 400 && error?.response?.status <= 599);\n        },\n        shouldResetTimeout: true // Reset the timeout between retries\n    });\n    const resp = await axios({\n        method: 'get',\n        url: connectorData.api,\n        headers: {\n            'Content-Type': 'application/json',\n            'Authorization': inputData.token,\n        },\n        params: {\n            filter: inputData.filter,\n            select: inputData.select,\n            decrypt: inputData.decrypt || false\n        },\n        timeout: inputData.timeout || process.env.DATASERVICE_TIMEOUT || 60000,\n    });\n    if (resp.data && _.isArray(resp.data) && _.size(resp.data) > 0) {\n        return { statusCode: resp.statusCode || resp.status, data: resp.data[0] };\n    } else {\n        throw { statusCode: 404, data: { message: 'Document Not Found' } };\n    }\n} catch (err) {\n    if (err.response) {\n        const error = new Error(`Axios request failed: ${err.response.status} - ${err.response.statusText}`);\n        error.statusCode = err.response.status;\n        error.data = err.response.data;\n        error.stack = err.stack;\n        throw error;\n    } else if (err.code === 'ECONNABORTED') {\n        const error = new Error('Request timeout');\n        error.statusCode = 408;\n        error.code = err.code;\n        error.stack = err.stack;\n        throw error;\n    }\n    else {\n        throw err;\n    }\n}",
            "_lastUpdated": "2025-08-14T07:28:27.408Z",
            "_createdAt": "2024-04-15T18:56:04.641Z",
            "nodeId": "3513f045ab99e2d3db4f2074b3b26ff01e1980e37bfcdd0d69cc0bbf80596735",
            "__v": 4,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbab9b",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "Database",
            "type": "V1_DOCUMENTDB_INSERT_MANY",
            "connectorType": "DOCUMENTDB",
            "label": "DocumentDB Insert Many",
            "icon": "ni ni-database-write",
            "version": 1,
            "inputSchema": [
                {
                    "key": "data",
                    "type": "Schema"
                },
                {
                    "key": "collection",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "insertedCount",
                    "type": "Number"
                },
                {
                    "key": "insertedIds",
                    "type": "Array",
                    "subType": "String"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [
                "const result = await connectorData.collection.insertMany(inputData.data);",
                "return result;"
            ],
            "_lastUpdated": "2024-04-15T18:56:04.639Z",
            "_createdAt": "2024-04-15T18:56:04.639Z",
            "nodeId": "3979d48075a664db0a509e5f090c85c25e23b1780daf23931f8f7548436709ff",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbabbc",
            "_deleted": false,
            "_version": 13,
            "category": "PROCESS",
            "group": "DataService",
            "type": "V1_DATASERVICE_PUT",
            "connectorType": "DATASERVICE",
            "label": "Data Service Update",
            "icon": "ni ni-dataservice",
            "version": 1,
            "inputSchema": [
                {
                    "key": "filter",
                    "type": "String"
                },
                {
                    "key": "data",
                    "type": "DataService"
                },
                {
                    "key": "token",
                    "type": "String"
                },
                {
                    "key": "retries",
                    "type": "Number"
                },
                {
                    "key": "retryDelay",
                    "type": "Number"
                },
                {
                    "key": "timeout",
                    "type": "Number"
                }
            ],
            "outputSchema": [
                {
                    "key": "statusCode",
                    "type": "Number"
                },
                {
                    "key": "data",
                    "type": "DataService"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": "const axios = require('axios');\nconst axiosRetry = require('axios-retry').default;\ntry {\n    axiosRetry(axios, {\n        retries: inputData.retries || process.env.DATASERVICE_RETRIES || 0,\n        retryDelay: (retryCount, error) => {\n            logger.info(`[RETRY] Attempt #${retryCount} - Reason: ${error?.code || error?.message}`);\n            return (inputData.retryDelay || process.env.DATASERVICE_RETRY_DELAY || 1000);\n        },\n        onRetry: (retryCount, error, requestConfig) => {\n            logger.error(`[RETRYING] Retry #${retryCount} for ${requestConfig?.url} - Error: ${error?.message}`);\n        },\n        retryCondition: (error) => {\n            // Log the error to understand what's happening\n            logger.info('[DEBUG] Checking retry condition for error:', {\n                status: error?.response?.status,\n                code: error?.code,\n                message: error?.message\n            });\n            // Retry on 401, network errors, and 5xx errors\n            return axiosRetry.isNetworkOrIdempotentRequestError(error) ||\n                (error?.response?.status >= 400 && error?.response?.status <= 599);\n        },\n        shouldResetTimeout: true // Reset the timeout between retries\n    });\n    const resp = await axios({\n        method: 'put',\n        url: connectorData.api + '/utils/bulkUpdate',\n        headers: {\n            'Content-Type': 'application/json',\n            'Authorization': inputData.token,\n        },\n        data: inputData.data,\n        params: {\n            filter: inputData.filter\n        },\n        timeout: inputData.timeout || process.env.DATASERVICE_TIMEOUT || 60000,\n    });\n    return { statusCode: resp.statusCode || resp.status, data: resp.data };\n} catch (err) {\n    if (err.response) {\n        const error = new Error(`Axios request failed: ${err.response.status} - ${err.response.statusText}`);\n        error.statusCode = err.response.status;\n        error.data = err.response.data;\n        error.stack = err.stack;\n        throw error;\n    } else if (err.code === 'ECONNABORTED') {\n        const error = new Error('Request timeout');\n        error.statusCode = 408;\n        error.code = err.code;\n        error.stack = err.stack;\n        throw error;\n    }\n    else {\n        throw err;\n    }\n}",
            "_lastUpdated": "2025-07-24T10:03:59.228Z",
            "_createdAt": "2024-04-15T18:56:04.641Z",
            "nodeId": "422ef027da2911564a87174d081402a60c3de0381f653b09d58a6af4c9bf96c7",
            "__v": 4,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbabbd",
            "_deleted": false,
            "_version": 8,
            "category": "PROCESS",
            "group": "DataService",
            "type": "V1_DATASERVICE_DELETE",
            "connectorType": "DATASERVICE",
            "label": "Data Service Delete",
            "icon": "ni ni-dataservice",
            "version": 1,
            "inputSchema": [
                {
                    "key": "filter",
                    "type": "String"
                },
                {
                    "key": "token",
                    "type": "String"
                },
                {
                    "key": "retries",
                    "type": "Number"
                },
                {
                    "key": "retryDelay",
                    "type": "Number"
                },
                {
                    "key": "timeout",
                    "type": "Number"
                }
            ],
            "outputSchema": [
                {
                    "key": "statusCode",
                    "type": "Number"
                },
                {
                    "key": "data",
                    "type": "DataService"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": "const axios = require('axios');\nconst axiosRetry = require('axios-retry').default;\n\ntry {\n    axiosRetry(axios, {\n        retries: inputData.retries || process.env.DATASERVICE_RETRIES || 0,\n        retryDelay: (retryCount, error) => {\n            logger.info(`[RETRY] Attempt #${retryCount} - Reason: ${error?.code || error?.message}`);\n            return (inputData.retryDelay || process.env.DATASERVICE_RETRY_DELAY || 1000);\n        },\n        onRetry: (retryCount, error, requestConfig) => {\n            logger.error(`[RETRYING] Retry #${retryCount} for ${requestConfig?.url} - Error: ${error?.message}`);\n        },\n        retryCondition: (error) => {\n            // Log the error to understand what's happening\n            logger.info('[DEBUG] Checking retry condition for error:', {\n                status: error?.response?.status,\n                code: error?.code,\n                message: error?.message\n            });\n            // Retry on 401, network errors, and 5xx errors\n            return axiosRetry.isNetworkOrIdempotentRequestError(error) ||\n                (error?.response?.status >= 400 && error?.response?.status <= 599);\n        },\n        shouldResetTimeout: true // Reset the timeout between retries\n    });\n    const resp = await axios({\n        method: 'delete',\n        url: connectorData.api + '/utils/bulkDelete',\n        headers: {\n            'Content-Type': 'application/json',\n            'Authorization': inputData.token,\n        },\n        params: {\n            filter: inputData.filter\n        },\n        timeout: inputData.timeout || process.env.DATASERVICE_TIMEOUT || 60000,\n    });\n    return { statusCode: resp.statusCode || resp.status, data: resp.data };\n} catch (err) {\n    if (err.response) {\n        const error = new Error(`Axios request failed: ${err.response.status} - ${err.response.statusText}`);\n        error.statusCode = err.response.status;\n        error.data = err.response.data;\n        error.stack = err.stack;\n        throw error;\n    } else if (err.code === 'ECONNABORTED') {\n        const error = new Error('Request timeout');\n        error.statusCode = 408;\n        error.code = err.code;\n        error.stack = err.stack;\n        throw error;\n    }\n    else {\n        throw err;\n    }\n}",
            "_lastUpdated": "2025-07-24T10:05:51.332Z",
            "_createdAt": "2024-04-15T18:56:04.641Z",
            "nodeId": "5307fbb86875e98c8ec24c831efc7680c99e30ffabab7ce194241c80b39bcf55",
            "__v": 2,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbabbe",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "Misc",
            "type": "V1_BUFFER_PARSER",
            "connectorType": "NONE",
            "label": "Deserialize Buffer",
            "icon": "ni ni-parse",
            "version": 1,
            "inputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                },
                {
                    "key": "options",
                    "type": "ParseOptionSchema"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Schema"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [
                "let data;",
                "if (inputData.outputFormat.formatType == 'JSON') {",
                "    data = JSON.parse(inputData.data);",
                "} else if (inputData.outputFormat.formatType == 'XML') {",
                "    const { XMLParser } = require('fast-xml-parser');",
                "    const xmlParser = new XMLParser();",
                "    data = xmlParser.parse(inputData.data);",
                "} else {",
                "    const parseOptions =  {};",
                "    parseOptions.skipLines = inputData.options.skipLines;",
                "    parseOptions.skipRows = inputData.options.skipRows;",
                "    parseOptions.maxRows = inputData.options.maxRows;",
                "    parseOptions.sheetNo = inputData.options.sheetNo;",
                "    parseOptions.ignoreEmpty = inputData.options.ignoreEmpty;",
                "    parseOptions.delimiter = inputData.options.delimiter;",
                "    parseOptions.rowDelimiter = inputData.options.rowDelimiter;",
                "    data = await fileParserUtils.parseV1File(req, inputData.data, parseOptions);",
                "}",
                "return { data };"
            ],
            "_lastUpdated": "2024-04-15T18:56:04.641Z",
            "_createdAt": "2024-04-15T18:56:04.641Z",
            "nodeId": "05e0216730cdfb4a3a5c74db4c1af0add99e8b950ad7fd3cbd9befa6dc55af16",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbabbf",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "Misc",
            "type": "V1_BUFFER_RENDERER",
            "connectorType": "NONE",
            "label": "Serialize Buffer",
            "icon": "ni ni-render",
            "version": 1,
            "inputSchema": [
                {
                    "key": "data",
                    "type": "Schema"
                },
                {
                    "key": "options",
                    "type": "RenderOptionSchema"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [
                "let data;",
                "if (inputData.outputFormat.formatType == 'JSON') {",
                "    data = Buffer.from(JSON.stringify(inputData.data));",
                "} else if (inputData.outputFormat.formatType == 'XML') {",
                "    const { XMLBuilder } = require('fast-xml-parser');",
                "    const xmlBuilder = new XMLBuilder({ format: true, arrayNodeName: `${inputData.outputFormat.rootNodeName || 'ROOT'}` });",
                "    data = Buffer.from(xmlBuilder.build(inputData.data));",
                "} else {",
                "    const renderOptions =  {};",
                "    renderOptions.skipLines = inputData.options.skipLines;",
                "    renderOptions.skipRows = inputData.options.skipRows;",
                "    renderOptions.maxRows = inputData.options.maxRows;",
                "    renderOptions.sheetNo = inputData.options.sheetNo;",
                "    renderOptions.delimiter = inputData.options.delimiter;",
                "    renderOptions.ignoreEmpty = inputData.options.ignoreEmpty;",
                "    renderOptions.rowDelimiter = inputData.options.rowDelimiter;",
                "    data = await fileRenderUtils.renderV1File(req, inputData.data, renderOptions);",
                "}",
                "return { data };"
            ],
            "_lastUpdated": "2024-04-15T18:56:04.641Z",
            "_createdAt": "2024-04-15T18:56:04.641Z",
            "nodeId": "e8ef0979d3d90442f1a632bbae8a2ddc2d6555b0e0f6c1cfceff73332caafdbc",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbabc0",
            "_deleted": false,
            "_version": 4,
            "category": "PROCESS",
            "group": "Misc",
            "type": "V1_FORMDATA_PARSER",
            "connectorType": "NONE",
            "label": "Deserialize Form Data",
            "icon": "ni ni-parse",
            "version": 1,
            "inputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                },
                {
                    "key": "headers",
                    "type": "KeyValPair"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "FormData"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": "const busboy = require('busboy');\nlet data = await new Promise((resolve, reject) => {\n    const result = {};\n    const parser = busboy({ headers: { 'content-type': inputData.headers['content-type'] } });\n    parser.on('file', async (name, file, info) => {\n        result[name] = await commonUtils.getStreamAsBuffer(file);\n    });\n    parser.on('field', (name, val, info) => {\n        result[name] = val;\n    });\n    parser.on('close', () => {\n        resolve(result);\n    });\n    parser.on('error', (err) => {\n        reject(err);\n    });\n    parser.end(inputData.data);\n});\nreturn { data };",
            "_lastUpdated": "2025-01-29T14:44:54.631Z",
            "_createdAt": "2024-04-15T18:56:04.641Z",
            "nodeId": "6cc47a701d2c3af627be230f01d01e96c9b645cdc2dea7bad69ceaf7df27f04d",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbabc1",
            "_deleted": false,
            "_version": 5,
            "category": "PROCESS",
            "group": "Misc",
            "type": "V1_FORMDATA_RENDERER",
            "connectorType": "NONE",
            "label": "Serialize Form Data",
            "icon": "ni ni-render",
            "version": 1,
            "inputSchema": [
                {
                    "key": "data",
                    "type": "FormData"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                },
                {
                    "key": "headers",
                    "type": "KeyValPair"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": "const FormData = require('form-data');\nconst formData = new FormData();\nObject.keys(inputData.data).forEach((key) => {\n    formData.append(key, inputData.data[key]);\n});\nconst data = formData.getBuffer();\nconst headers = formData.getHeaders();\nreturn { data, headers };",
            "_lastUpdated": "2025-05-14T18:21:50.876Z",
            "_createdAt": "2024-04-15T18:56:04.641Z",
            "nodeId": "bb4c716b12ac6210a3cb05a00c243306bd94b61a8f55eccd5f4721bac445485d",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbabc2",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "Queue",
            "type": "V1_KAFKA_PUBLISHER",
            "connectorType": "KAFKA",
            "label": "Kafka Emitter",
            "icon": "ni ni-queue-publish",
            "version": 1,
            "inputSchema": [
                {
                    "key": "topic",
                    "type": "String"
                },
                {
                    "key": "groupId",
                    "type": "String"
                },
                {
                    "key": "data",
                    "type": "Buffer"
                }
            ],
            "outputSchema": [
                {
                    "key": "statusCode",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [
                "const { Kafka } = require('kafkajs');",
                "const kafkaOptions = {",
                "    clientId: connectorData.clientId,",
                "    brokers: connectorData.brokers",
                "};",
                "if (connectorData.ssl) {",
                "    kafkaOptions.ssl = connectorData.ssl;",
                "}",
                "if (connectorData.sasl) {",
                "    kafkaOptions.sasl = {",
                "        mechanism: 'plain',",
                "        username: connectorData.username,",
                "        password: connectorData.password,",
                "    };",
                "}",
                "const kafka = new Kafka(kafkaOptions);",
                "const producer = kafka.producer({ groupId: inputData.groupId });",
                "await producer.connect();",
                "await producer.send({ topic: inputData.topic, messages: [{ value: inputData.data }] });",
                "await producer.disconnect();",
                "return { statusCode: 200, message: 'Message Published' };"
            ],
            "_lastUpdated": "2024-04-15T18:56:04.641Z",
            "_createdAt": "2024-04-15T18:56:04.641Z",
            "nodeId": "2607b864f12c52ccd2c64a9bedbc719dd1602c17d0dfb76d1cf3fbf10ef3ca0f",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbabc3",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "Queue",
            "type": "V1_NATS_PUBLISHER",
            "connectorType": "NATS",
            "label": "NATS Emitter",
            "icon": "ni ni-queue-publish",
            "version": 1,
            "inputSchema": [
                {
                    "key": "queue",
                    "type": "String"
                },
                {
                    "key": "data",
                    "type": "Buffer"
                }
            ],
            "outputSchema": [
                {
                    "key": "statusCode",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [
                "await connectorData.natsCon.publish(inputData.queue, inputData.data);",
                "return { statusCode: 200, message: 'Message Published' };"
            ],
            "_lastUpdated": "2024-04-15T18:56:04.641Z",
            "_createdAt": "2024-04-15T18:56:04.641Z",
            "nodeId": "0a2d54e19e82667013cc424c8d0952afa87e1264b0fe1ebeb9b4152cbffb557f",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbabc4",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "Queue",
            "type": "V1_ACTIVEMQ_PUBLISHER",
            "connectorType": "ACTIVEMQ",
            "label": "ActiveMQ Emitter",
            "icon": "ni ni-queue-publish",
            "version": 1,
            "inputSchema": [
                {
                    "key": "queue",
                    "type": "String"
                },
                {
                    "key": "clientId",
                    "type": "String"
                },
                {
                    "key": "data",
                    "type": "Buffer"
                }
            ],
            "outputSchema": [
                {
                    "key": "statusCode",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [],
            "_lastUpdated": "2024-04-15T18:56:04.641Z",
            "_createdAt": "2024-04-15T18:56:04.641Z",
            "nodeId": "10434dd2a745d05d6680f2a535dd028784ced5fbefb9d84d4e0c745075416d13",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbabc5",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "EMail",
            "type": "V1_SMTP",
            "connectorType": "SMTP",
            "label": "SMTP",
            "icon": "ni ni-smtp",
            "version": 1,
            "inputSchema": [
                {
                    "key": "from",
                    "type": "String"
                },
                {
                    "key": "to",
                    "type": "String"
                },
                {
                    "key": "subject",
                    "type": "String"
                },
                {
                    "key": "text",
                    "type": "String"
                },
                {
                    "key": "html",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "messageId",
                    "type": "String"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [
                "const info = await connectorData.smtp.sendMail({",
                "    from: inputData.from,",
                "    to: inputData.to,",
                "    subject: inputData.subject,",
                "    text: inputData.text,",
                "    html: inputData.html",
                "});",
                "logger.ingo(\"Message sent: \", info.messageId);",
                "return { messageId: info.messageId };"
            ],
            "_lastUpdated": "2024-04-15T18:56:04.642Z",
            "_createdAt": "2024-04-15T18:56:04.642Z",
            "nodeId": "0c27c6705650bf77793e653a29f77b1b611012740d94b18446295a7adc46f0a2",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbabc6",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "EMail",
            "type": "V1_SEND_GRID",
            "connectorType": "SENDGRID",
            "label": "Send Grid",
            "icon": "ni ni-smtp",
            "version": 1,
            "inputSchema": [
                {
                    "key": "to",
                    "type": "String"
                },
                {
                    "key": "from",
                    "type": "String"
                },
                {
                    "key": "subject",
                    "type": "String"
                },
                {
                    "key": "text",
                    "type": "String"
                },
                {
                    "key": "html",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "statusCode",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [
                "const msg = {",
                "    to: inputdata.to,",
                "    from: inputdata.from,",
                "    subject: inputdata.subject,",
                "    text: inputdata.text,",
                "    html: inputdata.html",
                "};",
                "await connectorData.sgMail.send(msg);",
                "return { statusCode: 200, message: 'Mail Sent' };"
            ],
            "_lastUpdated": "2024-04-15T18:56:04.642Z",
            "_createdAt": "2024-04-15T18:56:04.642Z",
            "nodeId": "c85f99e6df298be7b8d83a445972625ee24e802921feae1d77e3244d2d66ae51",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbab9c",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "Database",
            "type": "V1_DOCUMENTDB_UPDATE_MANY",
            "connectorType": "DOCUMENTDB",
            "label": "DocumentDB Update Many",
            "icon": "ni ni-database-update",
            "version": 1,
            "inputSchema": [
                {
                    "key": "filter",
                    "type": "KeyValPair"
                },
                {
                    "key": "data",
                    "type": "Schema"
                },
                {
                    "key": "collection",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "matchedCount",
                    "type": "Number"
                },
                {
                    "key": "modifiedCountconstMongoClientRequireMongodbConstClientAwaitMongoClientConnectConnectorDataConnectionStringConstCollectionClientDbConnectorDataDatabaseCollectionInputDataCollectionConstResultAwaitCollectionUpdateManyInputDataFilterInputDataDataReturnResult",
                    "type": "Number"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [
                "const result = await connectorData.collection.updateMany(inputData.filter, inputData.data);",
                "return result;"
            ],
            "_lastUpdated": "2024-04-15T18:56:04.639Z",
            "_createdAt": "2024-04-15T18:56:04.639Z",
            "nodeId": "0f302872f23c34039b792fc31e920890ac0f56770739437af0bf88f2304d2d22",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbabc8",
            "_deleted": false,
            "_version": 13,
            "category": "PROCESS",
            "group": "HTTP",
            "type": "V1_RESPONSE",
            "connectorType": "NONE",
            "label": "Response",
            "icon": "ni ni-response",
            "version": 1,
            "inputSchema": [
                {
                    "key": "headers",
                    "type": "KeyValPair"
                },
                {
                    "key": "statusCode",
                    "type": "Number"
                },
                {
                    "key": "data",
                    "type": "Buffer"
                }
            ],
            "outputSchema": [
                {
                    "key": "statusCode",
                    "type": "Number"
                },
                {
                    "key": "data",
                    "type": "Buffer"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": "if (!_.isEmpty(inputData.headers)) {\n    _.forEach(inputData.headers, function (value, key) {\n        res.setHeader(key, value);\n    });\n}\nif (_.isNull(inputData.statusCode) || _.isUndefined(inputData.statusCode)) {\n    inputData.statusCode = 200;\n}\nreq.locals.isResponseSent = true;\nif (Buffer.isBuffer(inputData.data)) {\n    res.status(inputData.statusCode).end(inputData.data);\n} else if (_.isObject(inputData.data) && !(inputData.data instanceof (require('stream').Readable))) {\n    res.status(inputData.statusCode).json(inputData.data);\n} else if (inputData.data instanceof require('stream').Readable) {\n    res.status(inputData.statusCode);\n    inputData.data.pipe(res);\n} else {\n    res.status(inputData.statusCode).end(String(inputData.data));\n}\n\nreturn { statusCode: 200, data: inputData.data };",
            "_lastUpdated": "2025-03-12T17:51:58.156Z",
            "_createdAt": "2024-04-15T18:56:04.642Z",
            "nodeId": "65afe37e2f5ca543f2bbb2af2456b10c4c0a960e2fc7a8a551afe393da4533f0",
            "__v": 1,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbabbb",
            "_deleted": false,
            "_version": 10,
            "category": "PROCESS",
            "group": "DataService",
            "type": "V1_DATASERVICE_POST",
            "connectorType": "DATASERVICE",
            "label": "Data Service Create",
            "icon": "ni ni-dataservice",
            "version": 1,
            "inputSchema": [
                {
                    "key": "data",
                    "type": "Array",
                    "subType": "DataService"
                },
                {
                    "key": "token",
                    "type": "String"
                },
                {
                    "key": "retries",
                    "type": "Number"
                },
                {
                    "key": "retryDelay",
                    "type": "Number"
                },
                {
                    "key": "timeout",
                    "type": "Number"
                }
            ],
            "outputSchema": [
                {
                    "key": "statusCode",
                    "type": "Number"
                },
                {
                    "key": "data",
                    "type": "DataService"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": "const axios = require('axios');\nconst axiosRetry = require('axios-retry').default;\ntry {\n    axiosRetry(axios, {\n        retries: inputData.retries || process.env.DATASERVICE_RETRIES || 0,\n        retryDelay: (retryCount, error) => {\n            logger.info(`[RETRY] Attempt #${retryCount} - Reason: ${error?.code || error?.message}`);\n            return (inputData.retryDelay || process.env.DATASERVICE_RETRY_DELAY || 1000);\n        },\n        onRetry: (retryCount, error, requestConfig) => {\n            logger.error(`[RETRYING] Retry #${retryCount} for ${requestConfig?.url} - Error: ${error?.message}`);\n        },\n        retryCondition: (error) => {\n            // Log the error to understand what's happening\n            logger.info('[DEBUG] Checking retry condition for error:', {\n                status: error?.response?.status,\n                code: error?.code,\n                message: error?.message\n            });\n            // Retry on 401, network errors, and 5xx errors\n            return axiosRetry.isNetworkOrIdempotentRequestError(error) ||\n                (error?.response?.status >= 400 && error?.response?.status <= 599);\n        },\n        shouldResetTimeout: true // Reset the timeout between retries\n    });\n    const resp = await axios({\n        method: 'post',\n        url: connectorData.api,\n        headers: {\n            'Content-Type': 'application/json',\n            'Authorization': inputData.token,\n        },\n        data: inputData.data,\n        timeout: inputData.timeout || process.env.DATASERVICE_TIMEOUT || 60000,\n    });\n    return { statusCode: resp.statusCode || resp.status, data: resp.data };\n} catch (err) {\n    if (err.response) {\n        const error = new Error(`Axios request failed: ${err.response.status} - ${err.response.statusText}`);\n        error.statusCode = err.response.status;\n        error.data = err.response.data;\n        error.stack = err.stack;\n        throw error;\n    } else if (err.code === 'ECONNABORTED') {\n        const error = new Error('Request timeout');\n        error.statusCode = 408;\n        error.code = err.code;\n        error.stack = err.stack;\n        throw error;\n    }\n    else {\n        throw err;\n    }\n}",
            "_lastUpdated": "2025-07-24T10:07:29.524Z",
            "_createdAt": "2024-04-15T18:56:04.641Z",
            "nodeId": "dd7b3d8b6e47c52865094ebaebe6f0e36e1026e71c28d345b338187bbb9c8c07",
            "__v": 3,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661d7844dd0a8ba74ebbabc7",
            "_deleted": false,
            "_version": 2,
            "category": "PROCESS",
            "group": "Queue",
            "type": "V1_IBM_MQ_PRODUCE",
            "connectorType": "IBMMQ",
            "label": "IBM MQ Produce",
            "icon": "ni ni-queue-publish",
            "version": 1,
            "inputSchema": [
                {
                    "key": "queue",
                    "type": "String"
                },
                {
                    "key": "data",
                    "type": "Buffer"
                }
            ],
            "outputSchema": [
                {
                    "key": "messageId",
                    "type": "String"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "code": [
                "const mq = require('ibmmq');",
                "const MQC = mq.MQC;",
                "function openQueue(client, MQDetails) {",
                "    let openOptions = MQC.MQOO_OUTPUT;",
                "    let objectDescriptor = new mq.MQOD();",
                "    objectDescriptor.ObjectName = MQDetails.queue;",
                "    objectDescriptor.ObjectType = MQC.MQOT_Q;",
                "    return new Promise((resolve, reject) => {",
                "        mq.Open(client, objectDescriptor, openOptions, function (err, queueClient) {",
                "            if (err) {",
                "                logger.error('Error Opening IBM MQ Topic :', err);",
                "                reject(err);",
                "            } else {",
                "                logger.info('IBM MQ Topic Opened :', MQDetails.queue);",
                "                resolve(queueClient);",
                "            }",
                "        });",
                "    })",
                "}",
                "function putMessage(client, message) {",
                "    var messageDescriptor = new mq.MQMD(); // Defaults are fine.",
                "    var putMessageOptions = new mq.MQPMO();",
                "    putMessageOptions.Options = MQC.MQPMO_NO_SYNCPOINT |",
                "        MQC.MQPMO_NEW_MSG_ID |",
                "        MQC.MQPMO_NEW_CORREL_ID;",
                "    messageDescriptor.Persistence = MQC.MQPER_PERSISTENT;",
                "    return new Promise((resolve, reject) => {",
                "        mq.Put(client, messageDescriptor, putMessageOptions, message, function (err) {",
                "            if (err) {",
                "                logger.error('Error While Publishing message on IBM MQ :', err);",
                "                reject(err);",
                "            } else {",
                "                const messageId = Buffer.from(messageDescriptor.MsgId).toString('hex')",
                "                logger.info('MsgId: ', messageId);",
                "                logger.info(\"Message Published to IBM MQ\");",
                "                resolve({ messageId });",
                "            }",
                "        });",
                "    })",
                "}",
                "const queueClient = await openQueue(connectorData.mqClient, { queue: inputData.queue });",
                "const result = await putMessage(queueClient, inputData.data);",
                "return result;"
            ],
            "_lastUpdated": "2024-04-15T18:56:04.642Z",
            "_createdAt": "2024-04-15T18:56:04.642Z",
            "nodeId": "6371fed0e87d7f17ee3744965be59725dcf4048ac86f6cdbf2c582e2f6e46b80",
            "__v": 0,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "661f677ab6c4907ccb5b7a39",
            "_deleted": false,
            "_version": 4,
            "category": "PROCESS",
            "group": "Misc",
            "type": "V1_LOGGER",
            "connectorType": "NONE",
            "label": "Logger",
            "icon": "ni ni-process",
            "version": 1,
            "inputSchema": [
                {
                    "key": "level",
                    "type": "String"
                },
                {
                    "key": "data",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {}
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "_lastUpdated": "2024-04-17T06:11:36.609Z",
            "_createdAt": "2024-04-17T06:08:58.397Z",
            "code": "logger[inputData.level](inputData.data)",
            "nodeId": "f5c8c3138a3a3cf6a740d97e3d0b23de615114b5bd9a597f07aa21a65e2ebd6d",
            "__v": 1,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "662c8c7e9dbbdb8750fcab52",
            "_deleted": false,
            "_version": 3,
            "category": "PROCESS",
            "group": "Misc",
            "type": "V1_NEW_LOGGER",
            "connectorType": "NONE",
            "label": "New Logger",
            "icon": "ni ni-cloud-file-rm",
            "version": 1,
            "inputSchema": [
                {
                    "key": "loglevel",
                    "type": "String"
                },
                {
                    "key": "data",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {}
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "_lastUpdated": "2024-04-27T05:27:10.969Z",
            "_createdAt": "2024-04-27T05:26:22.457Z",
            "code": "logger[inputData.loglevel](inputData.data)",
            "nodeId": "668d12b7f9f65269fb952a1af847e0f9fd6f65cf493020b87a5d06d71a6088e8",
            "__v": 1,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "662febc7b4f219c2aca2af4b",
            "_deleted": false,
            "_version": 34,
            "category": "TRIGGER",
            "group": "Queue",
            "type": "V1_SOLACE_CONSUME",
            "connectorType": "SOLACE",
            "label": "Solace Consume",
            "icon": "ni ni-queue-subscribe",
            "version": 1,
            "inputSchema": [
                {
                    "key": "queue",
                    "type": "String"
                },
                {
                    "key": "autoCommit",
                    "type": "Boolean"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Object",
                    "schema": [
                        {
                            "key": "data",
                            "type": "Buffer"
                        },
                        {
                            "key": "message",
                            "type": "JSObject"
                        }
                    ]
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "_lastUpdated": "2025-05-21T11:22:21.227Z",
            "_createdAt": "2024-04-29T18:49:43.898Z",
            "code": "const solace = require('solclientjs');\nconst consumer = connectorData.solaceSession.createMessageConsumer({\n    queueDescriptor: { name: inputData.queue, type: solace.DestinationType.QUEUE },\n    acknowledgeMode: solace.MessageConsumerAcknowledgeMode.CLIENT, // Required for late acknowledgment\n});\nconsumer.on(solace.MessageConsumerEventName.UP, () => {\n    console.log(`Listening on queue: ${inputData.queue}`);\n});\nconsumer.on(solace.MessageConsumerEventName.CONNECT_FAILED_ERROR, (error) => {\n    console.error(`Queue connection failed: ${error}`);\n});\nconsumer.on(solace.MessageConsumerEventName.DOWN, () => {\n    console.warn(`Queue consumer down: ${inputData.queue}`);\n});\nconsumer.on(solace.MessageConsumerEventName.MESSAGE, (message) => {\n    const payload = {\n        message: message,\n        type: null,\n        data: null\n    };\n\n    try {\n        if (message.getBinaryAttachment()) {\n            payload.data = message.getBinaryAttachment();\n            payload.type = 'binary';\n        } else if (message.getXmlContentDecoded()) {\n            payload.data = message.getXmlContentDecoded();\n            payload.type = 'xml-decoded';\n        } else if (message.getXmlContent()) {\n            payload.data = message.getXmlContent();\n            payload.type = 'xml-raw';\n        } else if (message.getText()) {\n            payload.data = message.getText();\n            payload.type = 'text';\n        } else {\n            console.warn('Solace Consume: Received unknown message type');\n        }\n    } catch (err) {\n        payload.data = null;\n        payload.type = 'error';\n        payload.error = `Failed to parse message: ${err.message}`;\n        console.error('Error while processing Solace message:', err);\n    }\n\n    StartProcess(payload);\n});\nconsumer.connect();",
            "nodeId": "bbdaced817c5d389614cf0d0d7212ae6dc84abeeb71a0704ab57ee6b68c9dc65",
            "__v": 5,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "662ff0d51b3219838412931a",
            "_deleted": false,
            "_version": 8,
            "category": "PROCESS",
            "group": "Queue",
            "type": "V1_SOLACE_ACK",
            "connectorType": "SOLACE",
            "label": "Solace Ack",
            "icon": "ni ni-process",
            "version": 1,
            "inputSchema": [
                {
                    "key": "message",
                    "type": "JSObject"
                }
            ],
            "outputSchema": [
                {
                    "key": "statusCode",
                    "type": "Number"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "_lastUpdated": "2025-03-10T11:51:17.742Z",
            "_createdAt": "2024-04-29T19:11:17.081Z",
            "code": "if (inputData.message && inputData.message.acknowledge) {\n    inputData.message.acknowledge();\n    logger.info('Message acknowledged.');\n} else {\n    logger.warn('Message cannot be acknowledged.');\n    logger.debug(typeof inputData.message.acknowledge);\n    logger.trace(inputData);\n}\nreturn { statusCode: 200 };",
            "nodeId": "d363fc1a7e9337d21167ca9ee7446ddbffc099226adba1b1658eff6ada2a4665",
            "__v": 1,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "662ff15b1b3219838412933e",
            "_deleted": false,
            "_version": 8,
            "category": "PROCESS",
            "group": "Queue",
            "type": "V1_SOLACE_PRODUCE",
            "connectorType": "SOLACE",
            "label": "Solace Produce",
            "icon": "ni ni-queue-publish",
            "version": 1,
            "inputSchema": [
                {
                    "key": "queue",
                    "type": "String"
                },
                {
                    "key": "data",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "statusCode",
                    "type": "Number"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "_lastUpdated": "2025-03-07T14:27:12.665Z",
            "_createdAt": "2024-04-29T19:13:31.181Z",
            "code": "const solace = require('solclientjs');\nconst solaceMessage = solace.SolclientFactory.createMessage();\nsolaceMessage.setDestination(new solace.Destination(inputData.queue, solace.DestinationType.QUEUE));\nif (Buffer.isBuffer(inputData.data)) {\n    solaceMessage.setBinaryAttachment(inputData.data);\n} else if (typeof inputData.data == 'object') {\n    solaceMessage.setBinaryAttachment(JSON.stringify(inputData.data));\n} else {\n    solaceMessage.setBinaryAttachment(inputData.data);\n}\nsolaceMessage.setDeliveryMode(solace.MessageDeliveryModeType.PERSISTENT);\nconnectorData.solaceSession.send(solaceMessage);\nlogger.info(`Sent to queue ${inputData.queue}`);\nreturn { message: `Sent to queue ${inputData.queue}` };",
            "nodeId": "24af22d575200c8aab05460941f9b81cdd020123dae61cbdc22bac6634fb853d",
            "__v": 2,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "6634b91b215a6d8733f51aef",
            "_deleted": false,
            "_version": 6,
            "category": "PROCESS",
            "group": "Misc",
            "type": "V1_PARSE_CSV",
            "connectorType": "NONE",
            "label": "Parse CSV",
            "icon": "ni ni-parse",
            "version": 1,
            "inputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                },
                {
                    "key": "parseOptions",
                    "schema": [
                        {
                            "key": "skipLines",
                            "type": "Number"
                        },
                        {
                            "key": "skipRows",
                            "type": "Number"
                        },
                        {
                            "key": "maxRows",
                            "type": "Number"
                        },
                        {
                            "key": "rowDelimiter",
                            "type": "String"
                        },
                        {
                            "key": "ignoreEmpty",
                            "type": "Boolean"
                        }
                    ],
                    "type": "Object"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Schema"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "_lastUpdated": "2024-06-25T13:15:54.165Z",
            "_createdAt": "2024-05-03T10:14:51.870Z",
            "code": "const fastcsv = require('fast-csv');\nlet data;\nlet parseOptions = {};\nif (inputData.parseOptions) {\n    parseOptions.skipLines = inputData.parseOptions.skipLines;\n    parseOptions.skipRows = inputData.parseOptions.skipRows;\n    parseOptions.maxRows = inputData.parseOptions.maxRows;\n    parseOptions.ignoreEmpty = inputData.parseOptions.ignoreEmpty || true;\n    parseOptions.rowDelimiter = inputData.parseOptions.rowDelimiter;\n    parseOptions.discardUnmappedColumns = true;\n}\nparseOptions = JSON.parse(JSON.stringify(parseOptions));\nconst arrayOfArrayData = await new Promise((resolve, reject) => {\n    const aoa = [];\n    fastcsv.parseString(inputData.data.toString(), parseOptions)\n        .on('error', err => {\n            reject(err);\n        }).on('data', row => {\n            aoa.push(row);\n        })\n        .on('end', rowCount => {\n            logger.debug('Parsed rows = ', rowCount);\n            resolve(aoa);\n        });\n});\ndata = await parseUtils.aoaToFormat(inputData.outputFormat, arrayOfArrayData);\nreturn { data };",
            "nodeId": "ce2d069a98d5e2a6eb957c2b56401b12f37029934cc959f08d27131e04cee9ab",
            "__v": 1,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "6634dd39215a6d8733f51b1a",
            "_deleted": false,
            "_version": 5,
            "category": "PROCESS",
            "group": "Misc",
            "type": "V1_RENDER_CSV",
            "connectorType": "NONE",
            "label": "Render CSV",
            "icon": "ni ni-render",
            "version": 1,
            "inputSchema": [
                {
                    "key": "data",
                    "type": "Schema"
                },
                {
                    "key": "renderOptions",
                    "schema": [
                        {
                            "key": "rowDelimiter",
                            "type": "String"
                        },
                        {
                            "key": "headers",
                            "type": "Boolean"
                        }
                    ],
                    "type": "Object"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "_lastUpdated": "2024-06-25T13:14:36.382Z",
            "_createdAt": "2024-05-03T12:48:57.030Z",
            "code": "const fastcsv = require('fast-csv');\nlet data;\nconst renderOptions = {};\nif (inputData.renderOptions) {\n    renderOptions.rowDelimiter = inputData.renderOptions.rowDelimiter;\n    renderOptions.headers = inputData.renderOptions.headers || false;\n}\nlet aoa = await renderUtils.formatToAoa(inputData.inputFormat, inputData.data, renderOptions);\ndata = await fastcsv.writeToBuffer(aoa, renderOptions);\nreturn { data };",
            "nodeId": "e249bf51a16cadf4062a4d6ada3f520f912ff4599031a689439ddbdee181d02e",
            "__v": 2,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "6635e342f3116f5624490855",
            "_deleted": false,
            "_version": 7,
            "category": "PROCESS",
            "group": "Misc",
            "type": "V1_PARSE_XML",
            "connectorType": "NONE",
            "label": "Parse XML",
            "icon": "ni ni-parse",
            "version": 1,
            "inputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                },
                {
                    "key": "ignoreAttributes",
                    "type": "Boolean"
                },
                {
                    "key": "attributeNamePrefix",
                    "type": "String"
                },
                {
                    "key": "arrayKeys",
                    "subType": "String",
                    "type": "Array"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Schema"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "_lastUpdated": "2025-04-14T06:52:54.505Z",
            "_createdAt": "2024-05-04T07:26:58.700Z",
            "code": "const { XMLParser } = require('fast-xml-parser');\nconst options = {};\nif (inputData.ignoreAttributes == 'false' || inputData.ignoreAttributes == false) {\n    options.ignoreAttributes = false;\n}\nif (!options.ignoreAttributes && !inputData.attributeNamePrefix) {\n    inputData.attributeNamePrefix = '@_';\n}\nif (inputData.attributeNamePrefix) {\n    options.attributeNamePrefix = inputData.attributeNamePrefix;\n}\n\nif (inputData.arrayKeys) {\n    let keys = inputData.arrayKeys;\n    if (typeof inputData.arrayKeys == 'string') {\n        keys = inputData.arrayKeys.split(',');\n    }\n    options.isArray = (name, jpath) => {\n        return keys.indexOf(name) > -1;\n    }\n}\n\nconst xmlParser = new XMLParser(options);\nconst data = xmlParser.parse(inputData.data);\nreturn { data };",
            "nodeId": "9a06f27557d3bac2e8e6702c6efb1c24f132392924b1335a543f776a3597553e",
            "__v": 2,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "6635e3f7f3116f562449086a",
            "_deleted": false,
            "_version": 4,
            "category": "PROCESS",
            "group": "Misc",
            "type": "V1_RENDER_XML",
            "connectorType": "NONE",
            "label": "Render XML",
            "icon": "ni ni-render",
            "version": 1,
            "inputSchema": [
                {
                    "key": "data",
                    "type": "Schema"
                },
                {
                    "key": "ignoreAttributes",
                    "type": "Boolean"
                },
                {
                    "key": "attributeNamePrefix",
                    "type": "String"
                },
                {
                    "key": "arrayKeys",
                    "subType": "String",
                    "type": "Array"
                },
                {
                    "key": "format",
                    "type": "Boolean"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "_lastUpdated": "2025-04-14T06:52:20.647Z",
            "_createdAt": "2024-05-04T07:29:59.069Z",
            "code": "const { XMLBuilder } = require('fast-xml-parser');\nconst options = {};\nif (inputData.ignoreAttributes == 'false' || inputData.ignoreAttributes == false) {\n    options.ignoreAttributes = false;\n}\nif (!options.ignoreAttributes && !inputData.attributeNamePrefix) {\n    inputData.attributeNamePrefix = '@_';\n}\nif (inputData.attributeNamePrefix) {\n    options.attributeNamePrefix = inputData.attributeNamePrefix;\n}\nif (inputData.format == 'true' || inputData.format == true) {\n    options.format = true;\n} else {\n    options.format = false;\n}\nif (inputData.arrayKeys) {\n    let keys = inputData.arrayKeys;\n    if (typeof inputData.arrayKeys == 'string') {\n        keys = inputData.arrayKeys.split(',');\n    }\n    options.isArray = (name, jpath) => {\n        return keys.indexOf(name) > -1;\n    }\n}\nconst xmlBuilder = new XMLBuilder(options);\nconst data = xmlBuilder.build(inputData.data);\nreturn { data };",
            "nodeId": "86bdc0347a655d2a5781227d0c599708a59dca2abc2dd15bff39fc247c2ed35e",
            "__v": 2,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "66474432972f279453c14cb6",
            "_deleted": false,
            "_version": 3,
            "category": "PROCESS",
            "group": "Misc",
            "type": "V1_PARSE_JSON",
            "connectorType": "NONE",
            "label": "Parse JSON",
            "icon": "ni ni-parse",
            "version": 1,
            "inputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Schema"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "_lastUpdated": "2024-05-17T11:49:52.146Z",
            "_createdAt": "2024-05-17T11:49:06.601Z",
            "code": "const data = JSON.parse(inputData.data);\nreturn { data };",
            "nodeId": "dcbeb89ea9ea011f0f2c596aebc1f3147669c9beb87e9479c375c1a6a8731710",
            "__v": 1,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "6647447a972f279453c14cc5",
            "_deleted": false,
            "_version": 3,
            "category": "PROCESS",
            "group": "Misc",
            "type": "V1_RENDER_JSON",
            "connectorType": "NONE",
            "label": "Render JSON",
            "icon": "ni ni-render",
            "version": 1,
            "inputSchema": [
                {
                    "key": "data",
                    "type": "Schema"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "_lastUpdated": "2024-05-17T11:50:43.616Z",
            "_createdAt": "2024-05-17T11:50:18.854Z",
            "code": "const data = JSON.stringify(inputData.data);\nreturn { data };",
            "nodeId": "ea27110841ba86a39f6e4b87ca009d70a3c54018e5df8be521b3304febe08f67",
            "__v": 1,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "6648888a7da4d30a5315f8f4",
            "_deleted": false,
            "_version": 12,
            "category": "PROCESS",
            "group": "DataService",
            "type": "V1_DATA_SERVICE_BULK_UPDATE",
            "connectorType": "DATASERVICE",
            "label": "Data Service Bulk Update",
            "icon": "ni ni-dataservice",
            "version": 1,
            "inputSchema": [
                {
                    "key": "keys",
                    "subType": "String",
                    "type": "Array"
                },
                {
                    "key": "data",
                    "type": "Array",
                    "subType": "DataService"
                },
                {
                    "key": "token",
                    "type": "String"
                },
                {
                    "key": "retries",
                    "type": "Number"
                },
                {
                    "key": "retryDelay",
                    "type": "Number"
                },
                {
                    "key": "timeout",
                    "type": "Number"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Array",
                    "subType": "DataService"
                },
                {
                    "key": "statusCode",
                    "type": "Number"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "_lastUpdated": "2025-07-24T10:08:57.573Z",
            "_createdAt": "2024-05-18T10:52:58.634Z",
            "code": "const axios = require('axios');\nconst axiosRetry = require('axios-retry').default;\n\ntry {\n    axiosRetry(axios, {\n        retries: inputData.retries || process.env.DATASERVICE_RETRIES || 0,\n        retryDelay: (retryCount, error) => {\n            logger.info(`[RETRY] Attempt #${retryCount} - Reason: ${error?.code || error?.message}`);\n            return (inputData.retryDelay || process.env.DATASERVICE_RETRY_DELAY || 1000);\n        },\n        onRetry: (retryCount, error, requestConfig) => {\n            logger.error(`[RETRYING] Retry #${retryCount} for ${requestConfig?.url} - Error: ${error?.message}`);\n        },\n        retryCondition: (error) => {\n            // Log the error to understand what's happening\n            logger.info('[DEBUG] Checking retry condition for error:', {\n                status: error?.response?.status,\n                code: error?.code,\n                message: error?.message\n            });\n            // Retry on 401, network errors, and 5xx errors\n            return axiosRetry.isNetworkOrIdempotentRequestError(error) ||\n                (error?.response?.status >= 400 && error?.response?.status <= 599);\n        },\n        shouldResetTimeout: true // Reset the timeout between retries\n    });\n    const resp = await axios({\n        method: 'post',\n        url: connectorData.api + '/utils/bulkUpsert',\n        headers: {\n            'Content-Type': 'application/json',\n            'Authorization': inputData.token,\n        },\n        data: {\n            key: inputData.keys,\n            docs: inputData.data\n        },\n        params: {\n            update: true,\n            insert: false\n        },\n        timeout: inputData.timeout || process.env.DATASERVICE_TIMEOUT || 60000,\n    });\n    return { statusCode: resp.statusCode || resp.status, data: resp.data };\n} catch (err) {\n    if (err.response) {\n        const error = new Error(`Axios request failed: ${err.response.status} - ${err.response.statusText}`);\n        error.statusCode = err.response.status;\n        error.data = err.response.data;\n        error.stack = err.stack;\n        throw error;\n    } else if (err.code === 'ECONNABORTED') {\n        const error = new Error('Request timeout');\n        error.statusCode = 408;\n        error.code = err.code;\n        error.stack = err.stack;\n        throw error;\n    }\n    else {\n        throw err;\n    }\n}",
            "nodeId": "325258fff743314ed1627439b1b601e17533e8ee1d59b17f466126c3a30220aa",
            "__v": 3,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "6671584334353992eb4b8e06",
            "_deleted": false,
            "_version": 11,
            "category": "PROCESS",
            "group": "Misc",
            "type": "V1_PARSE_DELIMITER",
            "connectorType": "NONE",
            "label": "Parse Delimiter",
            "icon": "ni ni-parse",
            "version": 1,
            "inputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                },
                {
                    "key": "parseOptions",
                    "type": "Object",
                    "schema": [
                        {
                            "key": "skipLines",
                            "type": "Number"
                        },
                        {
                            "key": "skipRows",
                            "type": "Number"
                        },
                        {
                            "key": "maxRows",
                            "type": "Number"
                        },
                        {
                            "key": "rowDelimiter",
                            "type": "String"
                        },
                        {
                            "key": "ignoreEmpty",
                            "type": "Boolean"
                        },
                        {
                            "key": "delimiter",
                            "type": "String"
                        }
                    ]
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Schema"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "_lastUpdated": "2024-06-25T13:16:29.929Z",
            "_createdAt": "2024-06-18T09:49:55.357Z",
            "code": "const fastcsv = require('fast-csv');\r\nlet data;\r\nlet parseOptions = {};\r\nif (inputData.parseOptions) {\r\n    parseOptions.skipLines = inputData.parseOptions.skipLines;\r\n    parseOptions.skipRows = inputData.parseOptions.skipRows;\r\n    parseOptions.maxRows = inputData.parseOptions.maxRows;\r\n    parseOptions.ignoreEmpty = inputData.parseOptions.ignoreEmpty || true;\r\n    parseOptions.rowDelimiter = inputData.parseOptions.rowDelimiter;\r\n    parseOptions.delimiter = inputData.parseOptions.delimiter;\r\n}\r\nparseOptions.discardUnmappedColumns = true;\r\nparseOptions = JSON.parse(JSON.stringify(parseOptions));\r\nconst arrayOfArrayData = await new Promise((resolve, reject) => {\r\n    const aoa = [];\r\n    fastcsv.parseString(Buffer.from(inputData.data).toString(), parseOptions)\r\n        .on('error', err => {\r\n            reject(err);\r\n        }).on('data', row => {\r\n            aoa.push(row);\r\n        })\r\n        .on('end', rowCount => {\r\n            logger.debug('Parsed rows = ', rowCount);\r\n            resolve(aoa);\r\n        });\r\n});\r\ndata = await parseUtils.aoaToFormat(inputData.outputFormat, arrayOfArrayData);\r\nreturn { data };",
            "nodeId": "3b100ad97b7193502050cc2beeb2760dd4a8987eed2545307aec17aae2272c07",
            "__v": 3,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "66732d49e8758f3518add7d5",
            "_deleted": false,
            "_version": 16,
            "category": "PROCESS",
            "group": "Misc",
            "type": "V1_PARSE_XLSX",
            "connectorType": "NONE",
            "label": "Parse XLSX",
            "icon": "ni ni-parse",
            "version": 1,
            "inputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                },
                {
                    "key": "parseOptions",
                    "schema": [
                        {
                            "key": "sheetNo",
                            "type": "Number"
                        },
                        {
                            "key": "skipLines",
                            "type": "Number"
                        },
                        {
                            "key": "skipRows",
                            "type": "Number"
                        },
                        {
                            "key": "maxRows",
                            "type": "Number"
                        },
                        {
                            "key": "ignoreEmpty",
                            "type": "Boolean"
                        },
                        {
                            "key": "rowDelimiter",
                            "type": "String"
                        },
                        {
                            "key": "delimiter",
                            "type": "String"
                        }
                    ],
                    "type": "Object"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Schema"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "_lastUpdated": "2024-06-25T13:16:41.207Z",
            "_createdAt": "2024-06-19T19:11:05.770Z",
            "code": "const XLSX = require('xlsx');\r\nconst fastcsv = require('fast-csv');\r\nlet data;\r\nlet parseOptions = {};\r\nif (inputData.parseOptions) {\r\n    parseOptions.skipLines = inputData.parseOptions.skipLines;\r\n    parseOptions.skipRows = inputData.parseOptions.skipRows;\r\n    parseOptions.maxRows = inputData.parseOptions.maxRows;\r\n    parseOptions.ignoreEmpty = inputData.parseOptions.ignoreEmpty || true;\r\n    parseOptions.rowDelimiter = inputData.parseOptions.rowDelimiter;\r\n    parseOptions.delimiter = inputData.parseOptions.delimiter;\r\n}\r\nparseOptions.discardUnmappedColumns = true;\r\nparseOptions = JSON.parse(JSON.stringify(parseOptions));\r\nconst workBook = XLSX.read(inputData.data);\r\ndata = XLSX.utils.sheet_to_csv(workBook.Sheets[workBook.SheetNames[(inputData.parseOptions.sheetNo || 0)]]);\r\nconst arrayOfArrayData = await new Promise((resolve, reject) => {\r\n    const aoa = [];\r\n    fastcsv.parseString(data, parseOptions)\r\n        .on('error', err => {\r\n            reject(err);\r\n        }).on('data', row => {\r\n            aoa.push(row);\r\n        })\r\n        .on('end', rowCount => {\r\n            logger.debug('Parsed rows = ', rowCount);\r\n            resolve(aoa);\r\n        });\r\n});\r\ndata = await parseUtils.aoaToFormat(inputData.outputFormat, arrayOfArrayData);\r\nreturn { data };",
            "nodeId": "ead5f42445cc7b1e1614e5e5d5d9f585e83a8e99c20e4fda39df32a72412b215",
            "__v": 6,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "6673e33ce8758f3518add8f6",
            "_deleted": false,
            "_version": 5,
            "category": "PROCESS",
            "group": "Misc",
            "type": "V1_PARSE_FIXED_LENGTH",
            "connectorType": "NONE",
            "label": "Parse Fixed Length",
            "icon": "ni ni-parse",
            "version": 1,
            "inputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                },
                {
                    "key": "parseOptions",
                    "schema": [
                        {
                            "key": "skipLines",
                            "type": "Number"
                        },
                        {
                            "key": "skipRows",
                            "type": "Number"
                        },
                        {
                            "key": "maxRows",
                            "type": "Number"
                        }
                    ],
                    "type": "Object"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Schema"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "_lastUpdated": "2024-06-25T13:16:51.049Z",
            "_createdAt": "2024-06-20T08:07:24.941Z",
            "code": "let data;\nconst parseOptions = {};\nif (inputData.parseOptions) {\n    parseOptions.skipLines = inputData.parseOptions.skipLines;\n    parseOptions.skipRows = inputData.parseOptions.skipRows;\n    parseOptions.maxRows = inputData.parseOptions.maxRows;\n}\ndata = await parseUtils.txtToFormat(inputData.outputFormat, inputData.data, parseOptions);\nreturn { data };",
            "nodeId": "1b89fbfa35b666de4fc17614b04955f69ea1770d6fd70c991dfc35d24c1d512e",
            "__v": 1,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "6673e4b8e8758f3518add943",
            "_deleted": false,
            "_version": 6,
            "category": "PROCESS",
            "group": "Misc",
            "type": "V1_RENDER_DELIMITER",
            "connectorType": "NONE",
            "label": "Render Delimiter",
            "icon": "ni ni-render",
            "version": 1,
            "inputSchema": [
                {
                    "key": "data",
                    "type": "Schema"
                },
                {
                    "key": "renderOptions",
                    "schema": [
                        {
                            "key": "delimiter",
                            "type": "String"
                        },
                        {
                            "key": "rowDelimiter",
                            "type": "String"
                        },
                        {
                            "key": "headers",
                            "type": "Boolean"
                        }
                    ],
                    "type": "Object"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "_lastUpdated": "2024-06-25T13:14:57.805Z",
            "_createdAt": "2024-06-20T08:13:44.948Z",
            "code": "const fastcsv = require('fast-csv');\nlet data;\nconst renderOptions = {};\nif (inputData.renderOptions) {\n    renderOptions.rowDelimiter = inputData.renderOptions.rowDelimiter;\n    renderOptions.delimiter = inputData.renderOptions.delimiter;\n    renderOptions.headers = inputData.renderOptions.headers || false;\n}\nlet aoa = await renderUtils.formatToAoa(inputData.inputFormat, inputData.data, renderOptions);\ndata = await fastcsv.writeToBuffer(aoa, renderOptions);\nreturn { data };",
            "nodeId": "4147b63fceb745c3d67ac169db45bbaa26189919dee9a868af4d8a10094a31db",
            "__v": 1,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "6673e735e8758f3518add967",
            "_deleted": false,
            "_version": 8,
            "category": "PROCESS",
            "group": "Misc",
            "type": "V1_RENDER_XLSX",
            "connectorType": "NONE",
            "label": "Render XLSX",
            "icon": "ni ni-render",
            "version": 1,
            "inputSchema": [
                {
                    "key": "data",
                    "type": "Schema"
                },
                {
                    "key": "renderOptions",
                    "schema": [
                        {
                            "key": "delimiter",
                            "type": "String"
                        },
                        {
                            "key": "rowDelimiter",
                            "type": "String"
                        },
                        {
                            "key": "headers",
                            "type": "Boolean"
                        },
                        {
                            "key": "bookType",
                            "type": "String"
                        }
                    ],
                    "type": "Object"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "_lastUpdated": "2024-09-23T05:58:52.673Z",
            "_createdAt": "2024-06-20T08:24:21.053Z",
            "code": "const fastcsv = require('fast-csv');\nconst XLSX = require('xlsx');\nlet data;\nconst renderOptions = {};\nif (inputData.renderOptions) {\n    renderOptions.rowDelimiter = inputData.renderOptions.rowDelimiter;\n    renderOptions.delimiter = inputData.renderOptions.delimiter;\n    renderOptions.headers = inputData.renderOptions.headers || false;\n    renderOptions.bookType = inputData.renderOptions.bookType;\n}\nif (!renderOptions.bookType) {\n    renderOptions.bookType = 'xlsx';\n}\nlet aoa = await renderUtils.formatToAoa(inputData.inputFormat, inputData.data, renderOptions);\ndata = await fastcsv.writeToBuffer(aoa, renderOptions);\nconst wb = XLSX.read(data, { type: 'buffer', raw: true });\ndata = XLSX.write(wb, { bookType: renderOptions.bookType, type: 'buffer' });\nreturn { data };",
            "nodeId": "136bb530c0b92ff7aff6e9599745de9c5cfcbfb729f6c68922b292a1a72d8c12",
            "__v": 2,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "6673e8bde8758f3518add994",
            "_deleted": false,
            "_version": 5,
            "category": "PROCESS",
            "group": "Misc",
            "type": "V1_RENDER_FIXED_LENGTH",
            "connectorType": "NONE",
            "label": "Render Fixed Length",
            "icon": "ni ni-render",
            "version": 1,
            "inputSchema": [
                {
                    "key": "data",
                    "type": "Schema"
                },
                {
                    "key": "renderOptions",
                    "schema": [
                        {
                            "key": "skipLines",
                            "type": "Number"
                        },
                        {
                            "key": "skipRows",
                            "type": "Number"
                        },
                        {
                            "key": "maxRows",
                            "type": "Number"
                        },
                        {
                            "key": "headers",
                            "type": "Boolean"
                        }
                    ],
                    "type": "Object"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "_lastUpdated": "2024-06-25T13:15:23.147Z",
            "_createdAt": "2024-06-20T08:30:53.878Z",
            "code": "let data;\nconst renderOptions = {};\nif (inputData.renderOptions) {\n    renderOptions.skipLines = inputData.renderOptions.skipLines;\n    renderOptions.skipRows = inputData.renderOptions.skipRows;\n    renderOptions.maxRows = inputData.renderOptions.maxRows;\n}\ndata = await renderUtils.formatToTxt(inputData.inputFormat, inputData.data, renderOptions);\nreturn { data };",
            "nodeId": "75055ca0bb62e36c06d2eac8c9acdfdd30def26eeb31471e3e7dd062791d375c",
            "__v": 2,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "66829ddce8758f3518addf8c",
            "_deleted": false,
            "_version": 6,
            "category": "TRIGGER",
            "group": "File",
            "type": "V1_DISK_POLLER",
            "connectorType": "DISK",
            "label": "Disk Poller",
            "icon": "ni ni-disk-ls",
            "version": 1,
            "inputSchema": [
                {
                    "key": "inputFolder",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "String"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "_lastUpdated": "2024-07-04T07:27:58.674Z",
            "_createdAt": "2024-07-01T12:15:24.204Z",
            "code": "const poller = require('chokidar');\n\nconst inputFolder = inputData.inputFolder;\n\nlogger.info(inputFolder)\n\nlet options = {\n    usePolling: true,\n    interval: 500,\n    binaryInterval: 500,\n}\n\nlogger.info(options)\n\nconst watcher = poller.watch(inputFolder, options)\n\nwatcher.on('add', (filePath) => {\n    StartProcess({ \n        event:\"ADD\",\n        data: filePath\n         })\n})\nwatcher.on('change', (filePath) => {\n    StartProcess({ \n        event:\"UPDATE\",\n        data: filePath\n         })\n})\nwatcher.on('unlink', (filePath) => {\n    StartProcess({ \n        event:\"DELETE\",\n        data: filePath\n         })\n})",
            "nodeId": "698192e0e7d27c5389c59b0c46636254eca4945cd504ca444c4f4942efa8f716",
            "__v": 2,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "669a67b5ed6134549fdebbb2",
            "_deleted": false,
            "_version": 22,
            "category": "PROCESS",
            "group": "Misc",
            "type": "V1_CALL_FLOW",
            "connectorType": "FLOW",
            "label": "Call Flow",
            "icon": "ni ni-http-client",
            "version": 1,
            "inputSchema": [
                {
                    "key": "data",
                    "type": "SchemaFree"
                },
                {
                    "key": "forEachRecord",
                    "type": "Boolean"
                },
                {
                    "key": "headers",
                    "type": "KeyValPair"
                },
                {
                    "key": "token",
                    "type": "String"
                },
                {
                    "key": "responseType",
                    "type": "String"
                },
                {
                    "key": "retries",
                    "type": "Number"
                },
                {
                    "key": "retryDelay",
                    "type": "Number"
                },
                {
                    "key": "timeout",
                    "type": "Number"
                },
                {
                    "key": "throwErrorOn4Xx",
                    "type": "Boolean"
                },
                {
                    "key": "method",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "statusCode",
                    "type": "Number"
                },
                {
                    "key": "data",
                    "type": "Buffer"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "_lastUpdated": "2025-07-31T15:35:50.395Z",
            "_createdAt": "2024-07-19T13:18:45.307Z",
            "code": "const axios = require('axios');\nconst axiosRetry = require('axios-retry').default;\n\ntry {\n    axiosRetry(axios, {\n        retries: inputData.retries || process.env.CALLFLOW_RETRIES || 0,\n        retryDelay: (retryCount, error) => {\n            logger.info(`[RETRY] Attempt #${retryCount} - Reason: ${error?.code || error?.message}`);\n            return (inputData.retryDelay || process.env.CALLFLOW_RETRY_DELAY || 1000);\n        },\n        onRetry: (retryCount, error, requestConfig) => {\n            logger.error(`[RETRYING] Retry #${retryCount} for ${requestConfig?.url} - Error: ${error?.message}`);\n        },\n        retryCondition: (error) => {\n            // Log the error to understand what's happening\n            logger.info('[DEBUG] Checking retry condition for error:', {\n                status: error?.response?.status,\n                code: error?.code,\n                message: error?.message\n            });\n            // Retry on 401, network errors, and 5xx errors\n            return axiosRetry.isNetworkOrIdempotentRequestError(error) ||\n                (error?.response?.status >= 500 && error?.response?.status <= 599);\n        },\n        shouldResetTimeout: true // Reset the timeout between retries\n    });\n\n    if (!inputData.headers) {\n        inputData.headers = {};\n    }\n\n    if (inputData.token) {\n        inputData.headers['Authorization'] = inputData.token;\n    }\n\n    let isDataArray = _.isArray(inputData.data);\n\n    if (inputData.forEachRecord && isDataArray) {\n        let promises = inputData.data.map(async (item) => {\n            try {\n                const resp = await axios({\n                    method: inputData.method || connectorData.method || 'POST',\n                    url: connectorData.api,\n                    headers: inputData.headers,\n                    data: item,\n                    responseType: inputData.responseType || 'json',\n                    timeout: inputData.timeout || 60000,\n                });\n                return {\n                    statusCode: resp.status,\n                    data: resp.data,\n                    headers: resp.headers\n                };\n            } catch (err) {\n                logger.error('got error response from flow :: ', connectorData.flow.name);\n                logger.error(err);\n                return {\n                    statusCode: err.response?.status || 500,\n                    data: err.response?.data || err.message,\n                    headers: err.response?.headers || {},\n                    stack: err?.stack\n                };\n            }\n        });\n\n        let allData = await Promise.all(promises);\n        return { statusCode: 200, data: allData };\n\n    } else {\n        const resp = await axios({\n            method: inputData.method || connectorData.method || 'POST',\n            url: connectorData.api,\n            headers: inputData.headers,\n            data: inputData.data,\n            responseType: inputData.responseType || 'json',\n            timeout: inputData.timeout || process.env.CALLFLOW_TIMEOUT || 60000,\n            validateStatus: function (status) {\n                if (inputData.throwErrorOn4xx) {\n                    return status >= 200 && status < 300;\n                } else {\n                    return status >= 200 && status < 500;\n                }\n            }\n        });\n\n        return { statusCode: resp.status, data: resp.data };\n    }\n\n} catch (err) {\n    logger.error('got error response from flow :: ', connectorData.flow.name);\n    logger.error(err);\n    const statusCode = err?.response?.status || err?.status || 500;\n    const error = new Error(err?.response?.data?.message || err?.message || 'Unknown error');\n    error.statusCode = statusCode;\n    error.code = err?.code || 'ERR_UNKNOWN';\n    error.stack = err?.stack || new Error().stack;\n\n    throw error;\n}",
            "nodeId": "99c80e08245da1f549a232e7e90450b5708122fa5a39ef3bdffa26ac01075d29",
            "__v": 7,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "669f31fded6134549fdebd86",
            "_deleted": false,
            "_version": 9,
            "category": "PROCESS",
            "group": "DataService",
            "type": "V1_DATA_SERVICE_UPDATE_ONE",
            "connectorType": "DATASERVICE",
            "label": "Data Service Update One",
            "icon": "ni ni-dataservice",
            "version": 1,
            "inputSchema": [
                {
                    "key": "id",
                    "type": "String"
                },
                {
                    "key": "data",
                    "type": "DataService"
                },
                {
                    "key": "token",
                    "type": "String"
                },
                {
                    "key": "retries",
                    "type": "Number"
                },
                {
                    "key": "retryDelay",
                    "type": "Number"
                },
                {
                    "key": "timeout",
                    "type": "Number"
                }
            ],
            "outputSchema": [
                {
                    "key": "statusCode",
                    "type": "Number"
                },
                {
                    "key": "data",
                    "type": "DataService"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "_lastUpdated": "2025-07-24T10:10:18.012Z",
            "_createdAt": "2024-07-23T04:30:53.470Z",
            "code": "const axios = require('axios');\r\nconst axiosRetry = require('axios-retry').default;\r\n\r\ntry {\r\n    axiosRetry(axios, {\r\n        retries: inputData.retries || process.env.DATASERVICE_RETRIES || 0,\r\n        retryDelay: (retryCount, error) => {\r\n            logger.info(`[RETRY] Attempt #${retryCount} - Reason: ${error?.code || error?.message}`);\r\n            return (inputData.retryDelay || process.env.DATASERVICE_RETRY_DELAY || 1000);\r\n        },\r\n        onRetry: (retryCount, error, requestConfig) => {\r\n            logger.error(`[RETRYING] Retry #${retryCount} for ${requestConfig?.url} - Error: ${error?.message}`);\r\n        },\r\n        retryCondition: (error) => {\r\n            // Log the error to understand what's happening\r\n            logger.info('[DEBUG] Checking retry condition for error:', {\r\n                status: error?.response?.status,\r\n                code: error?.code,\r\n                message: error?.message\r\n            });\r\n            // Retry on 401, network errors, and 5xx errors\r\n            return axiosRetry.isNetworkOrIdempotentRequestError(error) ||\r\n                (error?.response?.status >= 400 && error?.response?.status <= 599);\r\n        },\r\n        shouldResetTimeout: true // Reset the timeout between retries\r\n    });\r\n    const resp = await axios({\r\n        method: 'put',\r\n        url: connectorData.api + `/${inputData.id}`,\r\n        headers: {\r\n            'Content-Type': 'application/json',\r\n            'Authorization': inputData.token,\r\n        },\r\n        data: inputData.data,\r\n        timeout: inputData.timeout || process.env.DATASERVICE_TIMEOUT || 60000,\r\n    });\r\n    return { statusCode: resp.statusCode || resp.status, data: resp.data };\r\n} catch (err) {\r\n    if (err.response) {\r\n        const error = new Error(`Axios request failed: ${err.response.status} - ${err.response.statusText}`);\r\n        error.statusCode = err.response.status;\r\n        error.data = err.response.data;\r\n        error.stack = err.stack;\r\n        throw error;\r\n    } else if (err.code === 'ECONNABORTED') {\r\n        const error = new Error('Request timeout');\r\n        error.statusCode = 408;\r\n        error.code = err.code;\r\n        error.stack = err.stack;\r\n        throw error;\r\n    }\r\n    else {\r\n        throw err;\r\n    }\r\n}",
            "nodeId": "e51e4a50ec50d14efe595deaf6ae6f8fab9c21c2b8ad7a4510715d2b9c113954",
            "__v": 2,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "66a1eecaed6134549fdec0f2",
            "_deleted": false,
            "_version": 8,
            "category": "TRIGGER",
            "group": "Misc",
            "type": "V1_TIMER_MULTIPLE",
            "connectorType": "NONE",
            "label": "Timer Multiple",
            "icon": "ni ni-timer",
            "version": 1,
            "inputSchema": [
                {
                    "key": "cronList",
                    "subType": "Object",
                    "type": "Array",
                    "schema": [
                        {
                            "key": "expression",
                            "type": "String"
                        },
                        {
                            "key": "headers",
                            "type": "KeyValPair"
                        },
                        {
                            "key": "timezone",
                            "type": "String"
                        }
                    ]
                }
            ],
            "outputSchema": [
                {
                    "key": "timestamp",
                    "type": "String"
                },
                {
                    "key": "expression",
                    "type": "String"
                },
                {
                    "key": "headers",
                    "type": "KeyValPair"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "_lastUpdated": "2025-05-16T09:00:30.000Z",
            "_createdAt": "2024-07-25T06:20:58.328Z",
            "code": "const { CronJob } = require('cron');\nconst cronList = JSON.parse(inputData.cronList);\nconsole.log('-----------cronList-----------', cronList);\ncronList.forEach(item => {\n    try {\n        console.log('Item - ', item);\n        let timezone = (item.timezone && item.timezone.trim() !== '' && item.timezone.trim().toLowerCase() !== 'undefined') ? item.timezone : 'UTC';\n        console.log('Timezone - ', timezone);\n        const job = new CronJob(item.expression, async () => {\n            try {\n                const date = new Date();\n                const isoString = date.toISOString();\n                const payload = { timestamp: isoString, expression: item.expression, headers: item.headers };\n                const headers = _.merge({ 'dnio-remote-txn-id': isoString }, item.headers);\n                await StartProcess(payload, headers);\n            } catch (err) {\n                logger.error('TimerError - ', err);\n            }\n        },\n            null,\n            true,\n            timezone || 'UTC'\n        );\n    } catch (e) {\n        logger.error(`Failed to schedule cron job for expression \"${item.expression}\": ${e.message}`);\n    }\n});",
            "nodeId": "4bbe3c889b9aa5a19636b2f0aad285f96b555b188b9cae35b1ea1be7ac27b1ba",
            "__v": 2,
            "workspaceId": "DNIO",
            "public": true
        },
        {
            "_id": "6779374c64abb3d3cf53be75",
            "_deleted": false,
            "_version": 9,
            "workspaceId": "DNIO",
            "category": "TRIGGER",
            "group": "EMail",
            "type": "V1_POLL_MAILBOX",
            "connectorType": "IMAP",
            "label": "Poll Mailbox",
            "icon": "ni ni-imap",
            "version": 1,
            "inputSchema": [
                {
                    "key": "mailbox",
                    "type": "String"
                },
                {
                    "key": "criteria",
                    "type": "Array",
                    "subType": "String"
                },
                {
                    "key": "pollFrequency",
                    "type": "Number"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Array",
                    "subType": "Object",
                    "schema": [
                        {
                            "key": "seqno",
                            "type": "Number"
                        },
                        {
                            "key": "data",
                            "schema": [
                                {
                                    "key": "attachments",
                                    "type": "Array",
                                    "subType": "Object",
                                    "schema": [
                                        {
                                            "key": "type",
                                            "type": "String"
                                        },
                                        {
                                            "key": "content",
                                            "type": "Buffer"
                                        },
                                        {
                                            "key": "contentType",
                                            "type": "String"
                                        },
                                        {
                                            "key": "partId",
                                            "type": "String"
                                        },
                                        {
                                            "key": "release",
                                            "type": "JSObject"
                                        },
                                        {
                                            "key": "contentDisposition",
                                            "type": "String"
                                        },
                                        {
                                            "key": "filename",
                                            "type": "String"
                                        },
                                        {
                                            "key": "contentId",
                                            "type": "String"
                                        },
                                        {
                                            "key": "cid",
                                            "type": "String"
                                        },
                                        {
                                            "key": "headers",
                                            "type": "KeyValPair"
                                        },
                                        {
                                            "key": "checksum",
                                            "type": "String"
                                        },
                                        {
                                            "key": "size",
                                            "type": "Number"
                                        }
                                    ]
                                },
                                {
                                    "key": "headers",
                                    "type": "KeyValPair"
                                },
                                {
                                    "key": "headerLines",
                                    "type": "Array",
                                    "subType": "Object",
                                    "schema": [
                                        {
                                            "key": "key",
                                            "type": "String"
                                        },
                                        {
                                            "key": "line",
                                            "type": "String"
                                        }
                                    ]
                                },
                                {
                                    "key": "html",
                                    "type": "String"
                                },
                                {
                                    "key": "text",
                                    "type": "String"
                                },
                                {
                                    "key": "textAsHtml",
                                    "type": "String"
                                },
                                {
                                    "key": "subject",
                                    "type": "String"
                                },
                                {
                                    "key": "date",
                                    "type": "String"
                                },
                                {
                                    "key": "to",
                                    "type": "Object",
                                    "schema": [
                                        {
                                            "key": "value",
                                            "type": "Array",
                                            "subType": "Object",
                                            "schema": [
                                                {
                                                    "key": "address",
                                                    "type": "String"
                                                },
                                                {
                                                    "key": "name",
                                                    "type": "String"
                                                }
                                            ]
                                        },
                                        {
                                            "key": "html",
                                            "type": "String"
                                        },
                                        {
                                            "key": "text",
                                            "type": "String"
                                        }
                                    ]
                                },
                                {
                                    "key": "from",
                                    "type": "Object",
                                    "schema": [
                                        {
                                            "key": "value",
                                            "type": "Array",
                                            "subType": "Object",
                                            "schema": [
                                                {
                                                    "key": "address",
                                                    "type": "String"
                                                },
                                                {
                                                    "key": "name",
                                                    "type": "String"
                                                }
                                            ]
                                        },
                                        {
                                            "key": "html",
                                            "type": "String"
                                        },
                                        {
                                            "key": "text",
                                            "type": "String"
                                        }
                                    ]
                                },
                                {
                                    "key": "messageId",
                                    "type": "String"
                                }
                            ],
                            "type": "Object"
                        }
                    ]
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "public": true,
            "_lastUpdated": "2025-04-08T08:55:47.818Z",
            "_createdAt": "2025-01-04T13:27:40.546Z",
            "code": "const Imap = require('imap');\nconst { simpleParser } = require('mailparser');\nconst imapConfig = {\n    user: connectorData.user,\n    password: connectorData.password,\n    host: connectorData.host,\n    port: connectorData.port,\n    tls: connectorData.tls || true,\n    tlsOptions: {\n        rejectUnauthorized: false,\n    },\n};\n\nfunction fetchEmails() {\n    return new Promise((resolve, reject) => {\n        const messages = [];\n        const imap = new Imap(imapConfig);\n        imap.once('ready', function () {\n            logger.info('Looking into mailbox - ', inputData.mailbox);\n            imap.openBox(inputData.mailbox, true, (err, box) => {\n                if (err) {\n                    reject(err);\n                    return;\n                }\n                logger.info('Searching for emails...:', inputData.criteria);\n                imap.search(inputData.criteria, (err, results) => {\n                    if (err) {\n                        reject(err);\n                        return;\n                    }\n                    logger.info(results);\n                    if (results.length === 0) {\n                        logger.info('No new emails found.');\n                        resolve(messages);\n                        return;\n                    }\n                    const fetch = imap.fetch(results, { bodies: '', struct: true });\n                    fetch.on('message', (msg, seqno) => {\n                        logger.info(`Processing message #${seqno}`);\n                        let rawEmail = '';\n                        msg.on('body', (stream) => {\n                            stream.on('data', (chunk) => {\n                                rawEmail += chunk.toString();\n                            });\n                        });\n                        msg.once('end', async () => {\n                            try {\n                                const parsed = await simpleParser(rawEmail);\n                                messages.push({\n                                    data: parsed,\n                                    seqno: seqno\n                                });\n                                if (messages.length === results.length) {\n                                    resolve(messages);\n                                }\n                            } catch (parseErr) {\n                                logger.error('Error parsing email:', parseErr.message);\n                            }\n                        });\n                    });\n                    fetch.once('error', (err) => {\n                        logger.error('Fetch error:', err.message);\n                        reject(err);\n                    });\n                    fetch.once('end', () => {\n                        logger.info('All messages processed.');\n                        imap.end();\n                    });\n                });\n            });\n        });\n        imap.once('error', function (err) {\n            logger.error('IMAP Error', err.message);\n            reject(err);\n        });\n        imap.once('end', function () {\n            logger.info('Connection ended');\n        });\n        imap.connect();\n    });\n}\n\nsetInterval(() => {\n    fetchEmails().then((messages) => {\n        if (messages && messages.length > 0) {\n            StartProcess({\n                data: messages\n            });\n        }\n    }).catch((err) => {\n        logger.error('Error on Polling Mailbox :', err.message);\n        logger.error(err);\n    });\n}, (inputData.pollFrequency || 10) * 1000);",
            "nodeId": "0c418558757f4ada15d2e53c67f0eb850a39de683e9ed400d74fb34c5383a7f0",
            "__v": 6
        },
        {
            "_id": "6788d77b43a82259a3abb918",
            "_deleted": false,
            "_version": 21,
            "workspaceId": "DNIO",
            "category": "TRIGGER",
            "group": "Queue",
            "type": "V1_RD_KAFKA_LISTENER",
            "connectorType": "KAFKA",
            "label": "RD Kafka Listener",
            "icon": "ni ni-queue-subscribe",
            "version": 1,
            "inputSchema": [
                {
                    "key": "topic",
                    "type": "String"
                },
                {
                    "key": "groupId",
                    "type": "String"
                },
                {
                    "key": "autoCommit",
                    "type": "Boolean"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                },
                {
                    "key": "message",
                    "type": "JSObject"
                },
                {
                    "key": "consumer",
                    "type": "JSObject"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "public": true,
            "_lastUpdated": "2025-01-27T06:40:15.778Z",
            "_createdAt": "2025-01-16T09:55:07.091Z",
            "code": "const Kafka = require('node-rdkafka');\r\nif (inputData.autoCommit == undefined || inputData.autoCommit == null) {\r\n    inputData.autoCommit = false;\r\n}\r\nconst kafkaOptions = {\r\n    'metadata.broker.list': connectorData.servers,\r\n    'security.protocol': connectorData.protocol,\r\n    'group.id': inputData.groupId,\r\n    'enable.auto.commit': inputData.autoCommit == true || inputData.autoCommit == 'true',\r\n}\r\nif (connectorData.sasl == 'true') {\r\n    kafkaOptions['sasl.username'] = connectorData.username;\r\n    kafkaOptions['sasl.password'] = connectorData.password;\r\n    kafkaOptions['sasl.mechanisms'] = connectorData.mechanism.toUpperCase();\r\n}\r\nlogger.trace('Kafka Options - ', kafkaOptions);\r\nconst consumer = new Kafka.KafkaConsumer(kafkaOptions, {\r\n    'auto.offset.reset': 'earliest'\r\n});\r\ntry {\r\n    logger.info('Connecting consumer...');\r\n    consumer.connect(null, (err, metadata) => {\r\n        if (err) {\r\n            logger.error('Error connecting to Kafka :: ', err);\r\n            process.exit(0);\r\n        } else {\r\n            logger.debug('Metadata :: ', metadata);\r\n        }\r\n    });\r\n    consumer.on('ready', () => {\r\n        logger.info('Kafka Consumer is ready');\r\n        const topic = inputData.topic;\r\n        consumer.subscribe([topic]);\r\n        logger.info(`Subscribed to topic: ${topic}`);\r\n        consumer.consume();\r\n    });\r\n    consumer.on('event.error', (err) => {\r\n        logger.error('Error from consumer:', err);\r\n        process.exit(0);\r\n    });\r\n    consumer.on('data', (message) => {\r\n        logger.debug(`Received message: ${message.value.toString()}`);\r\n        logger.info(`Topic: ${message.topic}, Partition: ${message.partition}, Offset: ${message.offset}`);\r\n        StartProcess({ message: message, data: message.value, consumer });\r\n    });\r\n} catch (err) {\r\n    logger.error('Error in consumer:', err);\r\n    process.exit(0);\r\n}\r\nprocess.on('SIGINT', function () {\r\n    consumer.disconnect((err) => {\r\n        logger.info('Disconnecting consumer...');\r\n        if (err) {\r\n            logger.info('Error disconnecting Consumer', err);\r\n        } else {\r\n            logger.info('Consumer disconnected');\r\n        }\r\n    });\r\n});",
            "nodeId": "bf12e5ccd830611dcfd5de1830d8f3edcbf8f12df26a0860b6552feaef936d75",
            "__v": 4
        },
        {
            "_id": "6788d79043a82259a3abb91e",
            "_deleted": false,
            "_version": 18,
            "workspaceId": "DNIO",
            "category": "PROCESS",
            "group": "Queue",
            "type": "V1_RD_KAFKA_EMITTER",
            "connectorType": "KAFKA",
            "label": "RD Kafka Emitter",
            "icon": "ni ni-queue-publish",
            "version": 1,
            "inputSchema": [
                {
                    "key": "topic",
                    "type": "String"
                },
                {
                    "key": "data",
                    "type": "Buffer"
                }
            ],
            "outputSchema": [
                {
                    "key": "statusCode",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "public": true,
            "_lastUpdated": "2025-01-27T06:39:34.192Z",
            "_createdAt": "2025-01-16T09:55:28.704Z",
            "code": "const Kafka = require('node-rdkafka');\r\n\r\nconst kafkaOptions = {\r\n    'metadata.broker.list': connectorData.servers,\r\n    'security.protocol': connectorData.protocol\r\n}\r\nif (connectorData.sasl == 'true') {\r\n    kafkaOptions['sasl.username'] = connectorData.username;\r\n    kafkaOptions['sasl.password'] = connectorData.password;\r\n    kafkaOptions['sasl.mechanisms'] = connectorData.mechanism.toUpperCase();\r\n}\r\n\r\nlogger.trace('Kafka Options - ', kafkaOptions);\r\n\r\nconst producer = new Kafka.Producer(kafkaOptions);\r\nconst connectProducer = (producer) => {\r\n    return new Promise((resolve, reject) => {\r\n        producer.connect(null, (err, metadata) => {\r\n            if (err) {\r\n                logger.error('Error connecting to Kafka :: ', err);\r\n                reject(err);\r\n            } else {\r\n                logger.debug('Metadata :: ', metadata);\r\n            }\r\n        });\r\n        producer.on('ready', () => {\r\n            logger.info('Kafka Producer is ready');\r\n            resolve();\r\n        });\r\n        producer.on('event.error', (err) => {\r\n            logger.error('Error from producer:', err);\r\n            reject(err);\r\n        });\r\n    });\r\n};\r\n\r\nconst disconnectProducer = (producer) => {\r\n    return new Promise((resolve, reject) => {\r\n        producer.disconnect((err) => {\r\n            logger.info('Disconnecting producer...');\r\n            if (err) {\r\n                reject(err);\r\n            } else {\r\n                resolve();\r\n            }\r\n        });\r\n    });\r\n};\r\n\r\ntry {\r\n    logger.info('Connecting producer...');\r\n    await connectProducer(producer);\r\n    logger.info('Producer is ready');\r\n    const topic = inputData.topic;\r\n    const message = Buffer.from(inputData.data);\r\n    let status = producer.produce(topic, null, message, null, Date.now());\r\n    if (status) {\r\n        logger.info(`Message sent to topic \"${topic}\"`);\r\n    }\r\n    return { status };\r\n} catch (err) {\r\n    logger.error('Error in producer lifecycle:', err);\r\n    return { statusCode: 500, message: err.message };\r\n} finally {\r\n    logger.info('Disconnecting producer...');\r\n    disconnectProducer(producer);\r\n    logger.info('Producer disconnected');\r\n}",
            "nodeId": "12df4ec5c8b9663d9c51f95ff627fd3a550ff636aa986bc29ed3fbc2403b20f9",
            "__v": 1
        },
        {
            "_id": "67897c4643a82259a3abba25",
            "_deleted": false,
            "_version": 3,
            "workspaceId": "DNIO",
            "category": "PROCESS",
            "group": "Queue",
            "type": "V1_RD_KAFKA_COMMIT",
            "connectorType": "NONE",
            "label": "RD Kafka Commit",
            "icon": "ni ni-process",
            "version": 1,
            "inputSchema": [
                {
                    "key": "consumer",
                    "type": "JSObject"
                },
                {
                    "key": "message",
                    "type": "JSObject"
                }
            ],
            "outputSchema": [
                {
                    "key": "status",
                    "type": "Boolean"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "public": true,
            "_lastUpdated": "2025-01-16T21:39:35.052Z",
            "_createdAt": "2025-01-16T21:38:14.824Z",
            "code": "inputData.consumer.commitMessage(inputData.message);\nlogger.info(`Message offset ${inputData.message.offset} acknowledged.`);\nreturn { status: true };",
            "nodeId": "9c80c46f10f17f6fffd39d9f3320bbf9e6cc359a77d2a4e2814a95f759a8997d",
            "__v": 1
        },
        {
            "_id": "67a5ce27ce18605876b72146",
            "_deleted": false,
            "_version": 5,
            "workspaceId": "DNIO",
            "category": "PROCESS",
            "group": "Database",
            "type": "V1_MONGO_DB_AGGREGATE",
            "connectorType": "MONGODB",
            "label": "MongoDB Aggregate",
            "icon": "ni ni-database-read",
            "version": 1,
            "inputSchema": [
                {
                    "key": "query",
                    "type": "SchemaFree"
                },
                {
                    "key": "collection",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "subType": "Schema",
                    "type": "Array"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "public": false,
            "_lastUpdated": "2025-07-30T09:12:11.794Z",
            "_createdAt": "2025-02-07T09:11:03.909Z",
            "code": "const result = await connectorData.db.collection(inputData.collection).aggregate(inputData.query).toArray();\nreturn { data: result };",
            "nodeId": "1391f0e917311eb305adfdab47970d66be7f1ae152d1d4ed953a52f6f480d2a9",
            "__v": 2
        },
        {
            "_id": "67cad57fce18605876b722c6",
            "_deleted": false,
            "_version": 7,
            "workspaceId": "DNIO",
            "category": "PROCESS",
            "group": "Queue",
            "type": "V1_SOLACE_PUBLISH",
            "connectorType": "SOLACE",
            "label": "Solace Publish",
            "icon": "ni ni-queue-publish",
            "version": 1,
            "inputSchema": [
                {
                    "key": "topic",
                    "type": "String"
                },
                {
                    "key": "data",
                    "type": "Buffer"
                },
                {
                    "key": "trackingId",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "message",
                    "type": "String"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "public": false,
            "_lastUpdated": "2025-05-21T13:59:16.118Z",
            "_createdAt": "2025-03-07T11:16:15.988Z",
            "code": "const solace = require('solclientjs');\nconst solaceMessage = solace.SolclientFactory.createMessage();\nsolaceMessage.setDestination(solace.SolclientFactory.createTopicDestination(inputData.topic));\n\n\nif (Buffer.isBuffer(inputData.data)) {\n    solaceMessage.setBinaryAttachment(inputData.data);\n} else if (typeof inputData.data == 'object') {\n    solaceMessage.setBinaryAttachment(JSON.stringify(inputData.data));\n} else {\n    solaceMessage.setBinaryAttachment(inputData.data);\n}\n\n\nsolaceMessage.setCorrelationId(inputData.trackingId);\nsolaceMessage.setCorrelationKey(inputData.trackingId);\nsolaceMessage.setApplicationMessageId(inputData.trackingId);\nsolaceMessage.setApplicationMessageType(\"string\");\nsolaceMessage.setXmlContent(inputData.data);\n\nsolaceMessage.setDeliveryMode(solace.MessageDeliveryModeType.DIRECT);\nconnectorData.solaceSession.send(solaceMessage);\nlogger.info(`Published to topic ${inputData.topic}`);\nreturn { message: `Published to topic ${inputData.topic}` };\n",
            "nodeId": "91c441917bd745ff654e0fb45f932606e78f50d4028bebf45d438d1983fb7e90",
            "__v": 2
        },
        {
            "_id": "67cad5a0ce18605876b722cc",
            "_deleted": false,
            "_version": 5,
            "workspaceId": "DNIO",
            "category": "TRIGGER",
            "group": "Queue",
            "type": "V1_SOLACE_SUBSCRIBE",
            "connectorType": "SOLACE",
            "label": "Solace Subscribe",
            "icon": "ni ni-queue-subscribe",
            "version": 1,
            "inputSchema": [
                {
                    "key": "topic",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Object",
                    "schema": [
                        {
                            "key": "data",
                            "type": "Buffer"
                        },
                        {
                            "key": "message",
                            "type": "JSObject"
                        }
                    ]
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "public": false,
            "_lastUpdated": "2025-03-10T12:04:34.628Z",
            "_createdAt": "2025-03-07T11:16:48.883Z",
            "code": "const solace = require('solclientjs');\nconnectorData.solaceSession.subscribe(\n    solace.SolclientFactory.createTopicDestination(topic),\n    true,\n    inputData.topic,\n    10000\n);\nconnectorData.solaceSession.on(solace.SessionEventCode.SUBSCRIPTION_OK, () => {\n    console.log(`Subscribed to ${inputData.topic}`);\n});\nconnectorData.solaceSession.on(solace.SessionEventCode.SUBSCRIPTION_ERROR, (error) => {\n    console.error(`Subscription failed: ${error}`);\n});\nconnectorData.solaceSession.on(solace.SessionEventCode.MESSAGE, (message) => {\n    let data = message.getBinaryAttachment();\n    StartProcess({\n        data,\n        message\n    });\n});",
            "nodeId": "5928770f3beac5b0cf3c2b134b62766a9373929b0f195619e04a268612ac189d",
            "__v": 2
        },
        {
            "_id": "67fb4fb3c72541c8314373dc",
            "_deleted": false,
            "_version": 3,
            "workspaceId": "DNIO",
            "category": "PROCESS",
            "group": "Misc",
            "type": "V1_SKIP_INTERACTION_LOG",
            "connectorType": "NONE",
            "label": "Skip Interaction Log",
            "icon": "ni ni-process",
            "version": 1,
            "inputSchema": [
                {
                    "key": "skipLogging",
                    "type": "Boolean"
                }
            ],
            "outputSchema": [
                {
                    "key": "statusCode",
                    "type": "Number"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "public": false,
            "_lastUpdated": "2025-04-13T05:55:40.172Z",
            "_createdAt": "2025-04-13T05:46:27.635Z",
            "code": "req.locals.skipInteraction = false;\nif (inputData.skipLogging == true || inputData.skipLogging == 'true') {\n    req.locals.skipInteraction = true;\n}",
            "nodeId": "0988700e587b5364786d8da02326694bb2f8ef9b134d2fea535a297ee76f6a82",
            "__v": 1
        },
        {
            "_id": "68244b1469e1c3c72af80b89",
            "_deleted": false,
            "_version": 4,
            "workspaceId": "DNIO",
            "category": "PROCESS",
            "group": "Security",
            "type": "V1_ENCRYPTION_PGP",
            "connectorType": "NONE",
            "label": "Encryption PGP",
            "icon": "ni ni-encrypt",
            "version": 1,
            "inputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                },
                {
                    "key": "type",
                    "type": "String"
                },
                {
                    "key": "format",
                    "type": "String"
                },
                {
                    "key": "passwords",
                    "subType": "String",
                    "type": "Array"
                },
                {
                    "key": "publicKey",
                    "type": "String"
                },
                {
                    "key": "passphrase",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "public": true,
            "_lastUpdated": "2025-05-15T06:11:55.600Z",
            "_createdAt": "2025-05-14T07:49:40.422Z",
            "code": "",
            "nodeId": "e438f7779f811e7b71cae4dab612722c5bd2b718057dfd36b175df0cf45931c9",
            "__v": 2
        },
        {
            "_id": "68244b2869e1c3c72af80b8f",
            "_deleted": false,
            "_version": 3,
            "workspaceId": "DNIO",
            "category": "PROCESS",
            "group": "Security",
            "type": "V1_DECRYPTION_PGP",
            "connectorType": "NONE",
            "label": "Decryption PGP",
            "icon": "ni ni-decrypt",
            "version": 1,
            "inputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                },
                {
                    "key": "type",
                    "type": "String"
                },
                {
                    "key": "format",
                    "type": "String"
                },
                {
                    "key": "passwords",
                    "subType": "String",
                    "type": "Array"
                },
                {
                    "key": "privateKey",
                    "type": "String"
                },
                {
                    "key": "passphrase",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "public": true,
            "_lastUpdated": "2025-05-15T06:12:43.624Z",
            "_createdAt": "2025-05-14T07:50:00.077Z",
            "code": "",
            "nodeId": "e0183e72f596f0a815bc12455eed70b7f82c903b80ccba06f47e79588852bca5",
            "__v": 1
        },
        {
            "_id": "68244b4469e1c3c72af80b95",
            "_deleted": false,
            "_version": 4,
            "workspaceId": "DNIO",
            "category": "PROCESS",
            "group": "Security",
            "type": "V1_ENCRYPTION_BASE_64",
            "connectorType": "NONE",
            "label": "Encryption Base64",
            "icon": "ni ni-encrypt",
            "version": 1,
            "inputSchema": [
                {
                    "key": "data",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "String"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "public": true,
            "_lastUpdated": "2025-05-15T06:01:28.816Z",
            "_createdAt": "2025-05-14T07:50:28.362Z",
            "code": "",
            "nodeId": "ebaa03e768861a40bdcfb1dae51b9353abc1b6ce1d0fa413f7145bd82f836f61",
            "__v": 1
        },
        {
            "_id": "68244b5669e1c3c72af80b9d",
            "_deleted": false,
            "_version": 3,
            "workspaceId": "DNIO",
            "category": "PROCESS",
            "group": "Security",
            "type": "V1_DECRYPTION_BASE_64",
            "connectorType": "NONE",
            "label": "Decryption Base64",
            "icon": "ni ni-decrypt",
            "version": 1,
            "inputSchema": [
                {
                    "key": "data",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "String"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "public": true,
            "_lastUpdated": "2025-05-15T06:01:42.020Z",
            "_createdAt": "2025-05-14T07:50:46.330Z",
            "code": "",
            "nodeId": "13c32840be23094ff60f1b58c91773adfce63817c28411c57a594687ff45226b",
            "__v": 1
        },
        {
            "_id": "68244b8d69e1c3c72af80ba3",
            "_deleted": false,
            "_version": 3,
            "workspaceId": "DNIO",
            "category": "PROCESS",
            "group": "Security",
            "type": "V1_ENCRYPTION_SYMMETRIC",
            "connectorType": "NONE",
            "label": "Encryption Symmetric",
            "icon": "ni ni-encrypt",
            "version": 1,
            "inputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                },
                {
                    "key": "secret",
                    "type": "String"
                },
                {
                    "key": "algo",
                    "type": "String"
                },
                {
                    "key": "inputEncoding",
                    "type": "String"
                },
                {
                    "key": "outputEncoding",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "public": true,
            "_lastUpdated": "2025-05-15T06:14:57.147Z",
            "_createdAt": "2025-05-14T07:51:41.762Z",
            "code": "",
            "nodeId": "9cab936bbf587a5e178791d0ae83ccdbda94321d0ece4d469306c2b0e34c38d2",
            "__v": 1
        },
        {
            "_id": "68244b9d69e1c3c72af80ba9",
            "_deleted": false,
            "_version": 5,
            "workspaceId": "DNIO",
            "category": "PROCESS",
            "group": "Security",
            "type": "V1_DECRYPTION_SYMMETRIC",
            "connectorType": "NONE",
            "label": "Decryption Symmetric",
            "icon": "ni ni-decrypt",
            "version": 1,
            "inputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                },
                {
                    "key": "secret",
                    "type": "String"
                },
                {
                    "key": "algo",
                    "type": "String"
                },
                {
                    "key": "inputEncoding",
                    "type": "String"
                },
                {
                    "key": "outputEncoding",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "public": true,
            "_lastUpdated": "2025-05-15T06:15:20.094Z",
            "_createdAt": "2025-05-14T07:51:57.060Z",
            "code": "",
            "nodeId": "75ea529929a0e5d42d2ac0e75b684781c0149478c2692510f8d027d63ba8f62b",
            "__v": 3
        },
        {
            "_id": "68244be469e1c3c72af80baf",
            "_deleted": false,
            "_version": 3,
            "workspaceId": "DNIO",
            "category": "PROCESS",
            "group": "Security",
            "type": "V1_ENCRYPTION_ASYMMETRIC",
            "connectorType": "NONE",
            "label": "Encryption Asymmetric",
            "icon": "ni ni-encrypt",
            "version": 1,
            "inputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                },
                {
                    "key": "publicKey",
                    "type": "String"
                },
                {
                    "key": "passphrase",
                    "type": "String"
                },
                {
                    "key": "inputEncoding",
                    "type": "String"
                },
                {
                    "key": "outputEncoding",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "public": true,
            "_lastUpdated": "2025-05-15T06:16:46.908Z",
            "_createdAt": "2025-05-14T07:53:08.835Z",
            "code": "",
            "nodeId": "ea4aed49b0031363250d6f1f2663863717337ae02544ea534f88ba11680f1739",
            "__v": 1
        },
        {
            "_id": "68244bfa69e1c3c72af80bb5",
            "_deleted": false,
            "_version": 3,
            "workspaceId": "DNIO",
            "category": "PROCESS",
            "group": "Security",
            "type": "V1_DECRYPTION_ASYMMETRIC",
            "connectorType": "NONE",
            "label": "Decryption Asymmetric",
            "icon": "ni ni-decrypt",
            "version": 1,
            "inputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                },
                {
                    "key": "privateKey",
                    "type": "String"
                },
                {
                    "key": "passphrase",
                    "type": "String"
                },
                {
                    "key": "inputEncoding",
                    "type": "String"
                },
                {
                    "key": "outputEncoding",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "public": true,
            "_lastUpdated": "2025-05-15T06:17:24.815Z",
            "_createdAt": "2025-05-14T07:53:30.184Z",
            "code": "",
            "nodeId": "3043104a3756eb0ca03c132bc73d4e9088f80f4e0567e4de69c0905c44c5ef02",
            "__v": 1
        },
        {
            "_id": "68244f1569e1c3c72af80bd3",
            "_deleted": false,
            "_version": 3,
            "workspaceId": "DNIO",
            "category": "PROCESS",
            "group": "Misc",
            "type": "V1_PARSE_EDI",
            "connectorType": "NONE",
            "label": "Parse EDI",
            "icon": "ni ni-parse",
            "version": 1,
            "inputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Schema"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "public": true,
            "_lastUpdated": "2025-05-15T05:59:51.522Z",
            "_createdAt": "2025-05-14T08:06:45.492Z",
            "code": "",
            "nodeId": "7301ffed0b11ffb166307165ea02e0a653166b138638944008d2aaa1614615c2",
            "__v": 1
        },
        {
            "_id": "68244f2b69e1c3c72af80bd9",
            "_deleted": false,
            "_version": 3,
            "workspaceId": "DNIO",
            "category": "PROCESS",
            "group": "Misc",
            "type": "V1_RENDER_EDI",
            "connectorType": "NONE",
            "label": "Render EDI",
            "icon": "ni ni-render",
            "version": 1,
            "inputSchema": [
                {
                    "key": "data",
                    "type": "Schema"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "public": true,
            "_lastUpdated": "2025-05-15T06:00:08.692Z",
            "_createdAt": "2025-05-14T08:07:07.375Z",
            "code": "",
            "nodeId": "6bae1074e84392d5bb427b60ccd1c3d96a6198cf2047abc615a58cb1a9e61559",
            "__v": 1
        },
        {
            "_id": "682450b469e1c3c72af80bdf",
            "_deleted": false,
            "_version": 3,
            "workspaceId": "DNIO",
            "category": "PROCESS",
            "group": "Misc",
            "type": "V1_PARSE_MT",
            "connectorType": "NONE",
            "label": "Parse MT",
            "icon": "ni ni-parse",
            "version": 1,
            "inputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Schema"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "public": true,
            "_lastUpdated": "2025-05-15T06:00:22.255Z",
            "_createdAt": "2025-05-14T08:13:40.958Z",
            "code": "",
            "nodeId": "fa06cd8b3a21d6ca8e81d911b98c94663b7e94ba029cf4a35c89782db355e036",
            "__v": 1
        },
        {
            "_id": "682450c469e1c3c72af80be5",
            "_deleted": false,
            "_version": 3,
            "workspaceId": "DNIO",
            "category": "PROCESS",
            "group": "Misc",
            "type": "V1_RENDER_MT",
            "connectorType": "NONE",
            "label": "Render MT",
            "icon": "ni ni-render",
            "version": 1,
            "inputSchema": [
                {
                    "key": "data",
                    "type": "Schema"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "public": true,
            "_lastUpdated": "2025-05-15T06:00:36.531Z",
            "_createdAt": "2025-05-14T08:13:56.928Z",
            "code": "",
            "nodeId": "888be1c666c66c8e7a0189ed537e23710eb572a8131d0e4de4ccc0a1816d5b81",
            "__v": 1
        },
        {
            "_id": "68359f80139664c176f04440",
            "_deleted": false,
            "_version": 3,
            "workspaceId": "DNIO",
            "category": "PROCESS",
            "group": "Misc",
            "type": "V1_PARSE_ACH",
            "connectorType": "NONE",
            "label": "Parse ACH",
            "icon": "ni ni-parse",
            "version": 1,
            "inputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Schema"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "public": false,
            "_lastUpdated": "2025-05-27T11:18:41.655Z",
            "_createdAt": "2025-05-27T11:18:24.778Z",
            "code": "",
            "nodeId": "8fe324c9e3c294cb903bd3e4e73015f8e2bb68118282d54d077bdb3352d90e94",
            "__v": 1
        },
        {
            "_id": "68359fb9139664c176f04448",
            "_deleted": false,
            "_version": 3,
            "workspaceId": "DNIO",
            "category": "PROCESS",
            "group": "Misc",
            "type": "V1_RENDER_ACH",
            "connectorType": "NONE",
            "label": "Render ACH",
            "icon": "ni ni-render",
            "version": 1,
            "inputSchema": [
                {
                    "key": "data",
                    "type": "Schema"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "public": false,
            "_lastUpdated": "2025-05-27T11:19:34.412Z",
            "_createdAt": "2025-05-27T11:19:21.552Z",
            "code": "",
            "nodeId": "02043cc9f2002a749c35af1369b9cff0ed27cc9041ed7f7b362a7059a2c3ff5d",
            "__v": 1
        },
        {
            "_id": "6859067143a8a209fc83a000",
            "_deleted": false,
            "_version": 16,
            "workspaceId": "DNIO",
            "category": "PROCESS",
            "group": "File",
            "type": "V1_AGENT_SEND_DYNAMIC",
            "connectorType": "NONE",
            "label": "AGENT_SEND_DYNAMIC",
            "icon": "ni ni-process",
            "version": 1,
            "inputSchema": [
                {
                    "key": "agents",
                    "subType": "Object",
                    "type": "Array",
                    "schema": [
                        {
                            "key": "agentId",
                            "type": "String"
                        },
                        {
                            "key": "outputDirectories",
                            "subType": "String",
                            "type": "Array"
                        },
                        {
                            "key": "fileData",
                            "type": "Buffer"
                        },
                        {
                            "key": "outputFileName",
                            "type": "String"
                        },
                        {
                            "key": "extract",
                            "type": "Boolean"
                        },
                        {
                            "key": "decryptFile",
                            "type": "Boolean"
                        }
                    ]
                }
            ],
            "outputSchema": [
                {
                    "key": "statusCode",
                    "type": "Number"
                },
                {
                    "key": "result",
                    "type": "SchemaFree"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "public": false,
            "_lastUpdated": "2025-07-01T08:45:55.621Z",
            "_createdAt": "2025-06-23T07:46:57.486Z",
            "code": "const agents = inputData.agents || [];\r\nlogger.debug('Agent_Send_Dynamic - ', agents);\r\nconst result = [];\r\nlet finalStatusCode = 200;\r\n\r\nif (!Array.isArray(agents) || agents.length === 0) {\r\n    return { statusCode: 400, result };\r\n}\r\n\r\nfor (const agentData of agents) {\r\n    try {\r\n        if (!agentData.outputDirectories ||\r\n            !Array.isArray(agentData.outputDirectories) ||\r\n            agentData.outputDirectories.length === 0 ||\r\n            agentData.outputDirectories.every(dir => dir === null || dir === undefined || dir === '')) {\r\n            throw new Error(`OutputDirectories is not configured for agentId: ${agentData.agentId}`);\r\n        }\r\n\r\n        const agentInput = {\r\n            agentId: agentData.agentId,\r\n            outputDirectories: agentData.outputDirectories,\r\n            outputFileName: agentData.outputFileName,\r\n            decryptFile: agentData.decryptFile,\r\n            extract: agentData.extract,\r\n            data: agentData.fileData\r\n        };\r\n\r\n        logger.debug('AgenInput - ', agentInput);\r\n        const agentDoc = await commonUtils.getAgent(agentData.agentId);\r\n        logger.debug('AgentDoc - ', agentDoc);\r\n        const downloadOptions = commonUtils.getAgentSendPayload(req, flowData, agentDoc, agentInput);\r\n        logger.info(`Sending File Download Request to ${agentData.agentId} Agent`);\r\n        const fileDetails = await agentUtils.sendAgentDownloadRequestV1(flowData._id, req, downloadOptions);\r\n        logger.debug('FileDetails - ', fileDetails);\r\n        result.push({\r\n            agentId: agentData.agentId,\r\n            status: 'success',\r\n            statusCode: 200,\r\n            data: fileDetails\r\n        });\r\n\r\n    } catch (err) {\r\n        logger.error(`Error Occurred on ${agentData.agentId} Agent Download`, err);\r\n        result.push({\r\n            agentId: agentData.agentId,\r\n            status: 'failure',\r\n            statusCode: 400,\r\n            data: { filename: agentData.outputFileName },\r\n            error: err,\r\n            message: err?.message || 'Unknown error'\r\n        });\r\n    }\r\n}\r\n\r\nconst allSuccess = result.every(r => r.status === 'success');\r\nconst anySuccess = result.some(r => r.status === 'success');\r\n\r\nif (!allSuccess && anySuccess) {\r\n    finalStatusCode = 206;\r\n} else if (!anySuccess) {\r\n    finalStatusCode = 500;\r\n    throw new Error(`Error Occurred on Agent_Send_Dynamic Node : ${JSON.stringify(result)}`);\r\n}\r\n\r\nreturn { statusCode: finalStatusCode, result };",
            "nodeId": "8adcf5d0823856e9950c104988673bc4b02b2a0ae2a2b0bf53aa11f3fb236543",
            "__v": 3
        },
        {
            "_id": "687f46a943a8a209fc83a3da",
            "_deleted": false,
            "_version": 2,
            "workspaceId": "DNIO",
            "category": "PROCESS",
            "group": "Database",
            "type": "V1_REDIS_SET",
            "connectorType": "REDIS",
            "label": "Redis Set",
            "icon": "ni ni-database-write",
            "version": 1,
            "inputSchema": [
                {}
            ],
            "outputSchema": [
                {}
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "public": false,
            "_lastUpdated": "2025-07-22T08:07:05.527Z",
            "_createdAt": "2025-07-22T08:07:05.527Z",
            "code": [],
            "nodeId": "379f03913e94850f467dd8905806a91337e9ba2989879efc31eb6fa992b21aa2",
            "__v": 0
        },
        {
            "_id": "687f46c643a8a209fc83a3e0",
            "_deleted": false,
            "_version": 2,
            "workspaceId": "DNIO",
            "category": "PROCESS",
            "group": "Database",
            "type": "V1_REDIS_GET",
            "connectorType": "REDIS",
            "label": "Redis Get",
            "icon": "ni ni-database-read",
            "version": 1,
            "inputSchema": [
                {}
            ],
            "outputSchema": [
                {}
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "public": false,
            "_lastUpdated": "2025-07-22T08:07:34.842Z",
            "_createdAt": "2025-07-22T08:07:34.842Z",
            "code": [],
            "nodeId": "52aec3704827f817a38797f077520bd672edd96e64845d38df41237eed8dd104",
            "__v": 0
        },
        {
            "_id": "687f46e543a8a209fc83a3e6",
            "_deleted": false,
            "_version": 2,
            "workspaceId": "DNIO",
            "category": "PROCESS",
            "group": "Database",
            "type": "V1_REDIS_DELETE",
            "connectorType": "REDIS",
            "label": "Redis Delete",
            "icon": "ni ni-database-delete",
            "version": 1,
            "inputSchema": [
                {}
            ],
            "outputSchema": [
                {}
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "public": false,
            "_lastUpdated": "2025-07-22T08:08:05.368Z",
            "_createdAt": "2025-07-22T08:08:05.368Z",
            "code": [],
            "nodeId": "6968cb83c5e8d516a9d868a3210d65f8637cda54c538cf900d086436cccc4ee9",
            "__v": 0
        },
        {
            "_id": "687f471943a8a209fc83a3ec",
            "_deleted": false,
            "_version": 2,
            "workspaceId": "DNIO",
            "category": "PROCESS",
            "group": "Database",
            "type": "V1_REDIS_LIST",
            "connectorType": "REDIS",
            "label": "Redis List",
            "icon": "ni ni-database-read",
            "version": 1,
            "inputSchema": [
                {}
            ],
            "outputSchema": [
                {}
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "public": false,
            "_lastUpdated": "2025-07-22T08:08:57.356Z",
            "_createdAt": "2025-07-22T08:08:57.356Z",
            "code": [],
            "nodeId": "0e2546d99574d076be3bf867750ac347f1d5360d29f321ca507753298c6f0b22",
            "__v": 0
        },
        {
            "_id": "687f477a43a8a209fc83a3f2",
            "_deleted": false,
            "_version": 6,
            "workspaceId": "DNIO",
            "category": "PROCESS",
            "group": "Tools",
            "type": "V1_CHECK_SOFT_LOCK",
            "connectorType": "REDIS",
            "label": "Check Soft Lock",
            "icon": "ni ni-process",
            "version": 1,
            "inputSchema": [
                {
                    "key": "processKey",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Object",
                    "schema": [
                        {
                            "key": "status",
                            "type": "Boolean"
                        }
                    ]
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "public": false,
            "_lastUpdated": "2025-07-22T09:27:36.007Z",
            "_createdAt": "2025-07-22T08:10:34.826Z",
            "code": "const key = 'PROCESS_LOCK:' + inputData.processKey;\nconst value = await connectorData.redisClient.get(key);\nreturn { data: { status: value } };",
            "nodeId": "eafbd49d0ab976327354ab83a461ea16e6fe1d5b00f95dcb3d61c8e5e02b3b9d",
            "__v": 2
        },
        {
            "_id": "687f47a143a8a209fc83a3f8",
            "_deleted": false,
            "_version": 8,
            "workspaceId": "DNIO",
            "category": "PROCESS",
            "group": "Tools",
            "type": "V1_APPLY_SOFT_LOCK",
            "connectorType": "REDIS",
            "label": "Apply Soft Lock",
            "icon": "ni ni-process",
            "version": 1,
            "inputSchema": [
                {
                    "key": "processKey",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Object",
                    "schema": [
                        {
                            "key": "status",
                            "type": "Boolean"
                        }
                    ]
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "public": false,
            "_lastUpdated": "2025-07-24T05:21:18.600Z",
            "_createdAt": "2025-07-22T08:11:13.655Z",
            "code": "const key = 'PROCESS_LOCK:' + inputData.processKey;\nconst ttl = inputData.ttl ? parseInt(inputData.ttl + '') : 600;\nconst value = await connectorData.redisClient.get(key);\nif (value == 'true') {\n    return { data: { status: false } };\n}\nawait connectorData.redisClient.set(key, \"true\", \"EX\", ttl);\nreturn { data: { status: true } };",
            "nodeId": "b0468a2ef39d8bdc41ae31bee8c2c0a6c43b4c67683f84e07dee4b42d3ba2d70",
            "__v": 2
        },
        {
            "_id": "687f47be43a8a209fc83a3fe",
            "_deleted": false,
            "_version": 8,
            "workspaceId": "DNIO",
            "category": "PROCESS",
            "group": "Tools",
            "type": "V1_RELEASE_SOFT_LOCK",
            "connectorType": "REDIS",
            "label": "Release Soft Lock",
            "icon": "ni ni-process",
            "version": 1,
            "inputSchema": [
                {
                    "key": "processKey",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Object",
                    "schema": [
                        {
                            "key": "status",
                            "type": "Boolean"
                        }
                    ]
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "public": false,
            "_lastUpdated": "2025-07-22T10:18:15.652Z",
            "_createdAt": "2025-07-22T08:11:42.568Z",
            "code": "const key = 'PROCESS_LOCK:' + inputData.processKey;\nawait connectorData.redisClient.del(key);\nreturn { data: { status: true } };",
            "nodeId": "ae5fbc89089e04f66930204ee25303b887394f43e8c80856368136685e0e3c4a",
            "__v": 2
        },
        {
            "_id": "6880ab5443a8a209fc83a494",
            "_deleted": false,
            "_version": 4,
            "workspaceId": "DNIO",
            "category": "PROCESS",
            "group": "DataService",
            "type": "V1_DATA_SERVICE_INSERT_MANY",
            "connectorType": "DATASERVICE",
            "label": "Data Service Insert Many",
            "icon": "ni ni-dataservice",
            "version": 1,
            "inputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                },
                {
                    "key": "token",
                    "type": "String"
                },
                {
                    "key": "timeout",
                    "type": "Number"
                },
                {
                    "key": "skipValidation",
                    "type": "Boolean"
                }
            ],
            "outputSchema": [
                {
                    "key": "statusCoded",
                    "type": "Number"
                },
                {
                    "key": "data",
                    "schema": [
                        {
                            "key": "insertedIds",
                            "subType": "String",
                            "type": "Array"
                        },
                        {
                            "key": "acknowledged"
                        }
                    ],
                    "type": "Object"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "public": false,
            "_lastUpdated": "2025-07-24T10:13:22.370Z",
            "_createdAt": "2025-07-23T09:28:52.976Z",
            "code": "const axios = require('axios');\nconst axiosRetry = require('axios-retry').default;\n\ntry {\n    axiosRetry(axios, {\n        retries: inputData.retries || process.env.DATASERVICE_RETRIES || 0,\n        retryDelay: (retryCount, error) => {\n            logger.info(`[RETRY] Attempt #${retryCount} - Reason: ${error?.code || error?.message}`);\n            return (inputData.retryDelay || process.env.DATASERVICE_RETRY_DELAY || 1000);\n        },\n        onRetry: (retryCount, error, requestConfig) => {\n            logger.error(`[RETRYING] Retry #${retryCount} for ${requestConfig?.url} - Error: ${error?.message}`);\n        },\n        retryCondition: (error) => {\n            // Log the error to understand what's happening\n            logger.info('[DEBUG] Checking retry condition for error:', {\n                status: error?.response?.status,\n                code: error?.code,\n                message: error?.message\n            });\n            // Retry on 401, network errors, and 5xx errors\n            return axiosRetry.isNetworkOrIdempotentRequestError(error) ||\n                (error?.response?.status >= 400 && error?.response?.status <= 599);\n        },\n        shouldResetTimeout: true // Reset the timeout between retries\n    });\n    const resp = await axios({\n        method: 'post',\n        url: connectorData.api + '/utils/many/insert?skipValidation=' + (inputData.skipValidation || false),\n        headers: {\n            'Content-Type': 'application/json',\n            'Authorization': inputData.token,\n        },\n        data: inputData.data,\n        timeout: inputData.timeout || process.env.DATASERVICE_TIMEOUT || 60000,\n    });\n    return { statusCode: resp.statusCode || resp.status, data: resp.data };\n} catch (err) {\n    if (err.response) {\n        const error = new Error(`Axios request failed: ${err.response.status} - ${err.response.statusText}`);\n        error.statusCode = err.response.status;\n        error.data = err.response.data;\n        error.stack = err.stack;\n        throw error;\n    } else if (err.code === 'ECONNABORTED') {\n        const error = new Error('Request timeout');\n        error.statusCode = 408;\n        error.code = err.code;\n        error.stack = err.stack;\n        throw error;\n    }\n    else {\n        throw err;\n    }\n}",
            "nodeId": "70e63e2786236e1a6b788d380d40a3f5606774d0bca20adf07fff4461926d4eb",
            "__v": 1
        },
        {
            "_id": "68b85529d7a42e055722fb00",
            "_deleted": false,
            "_version": 9,
            "workspaceId": "DNIO",
            "category": "PROCESS",
            "group": "AIML",
            "type": "V1_AI_SUMMARY",
            "connectorType": "NONE",
            "label": "AI Summary",
            "icon": "ni ni-ai",
            "version": 1,
            "inputSchema": [
                {
                    "key": "prompt",
                    "type": "String"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Object",
                    "schema": [
                        {
                            "key": "message",
                            "type": "String"
                        },
                        {
                            "key": "reason",
                            "type": "String"
                        }
                    ]
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "public": false,
            "_lastUpdated": "2025-09-03T16:29:28.135Z",
            "_createdAt": "2025-09-03T14:48:09.051Z",
            "code": "const axios = require('axios');\nconst aiQueryConfig = {\n    method: 'POST',\n    maxBodyLength: Infinity,\n    url: ' https://dnimbus-partner-workspace.cloud.databricks.com/serving-endpoints/databricks-meta-llama-3-1-8b-instruct/invocations',\n    headers: {\n        'Content-Type': 'application/json',\n        'Authorization': 'Basic ' + Buffer.from(process.env.DATABRICKS_USERNAME + \":\" + process.env.DATABRICKS_PASSWORD, \"utf-8\").toString(\"base64\")\n    },\n    data: {\n        \"messages\": [\n            {\n                \"role\": \"user\",\n                \"content\": inputData.prompt\n            }\n        ]\n    }\n};\nconst aiResponse = await axios.request(aiQueryConfig);\nreturn { data: { message: aiResponse.data.choices[0].message.content, finish_reason: aiResponse.data.choices[0].finish_reason } };",
            "nodeId": "60e6777d9c203874da5524eff915638b36afaf1774ad7de784278bf86ae3e817",
            "__v": 2
        },
        {
            "_id": "6910271683526ce389b1fb2b",
            "_deleted": false,
            "_version": 13,
            "workspaceId": "DNIO",
            "category": "PROCESS",
            "group": "Tools",
            "type": "V1_MAPPER",
            "connectorType": "NONE",
            "label": "Mapper",
            "icon": "",
            "version": 1,
            "inputSchema": [
                {
                    "key": "data",
                    "type": "Schema"
                }
            ],
            "outputSchema": [
                {
                    "key": "data",
                    "type": "Buffer"
                }
            ],
            "errorSchema": [
                {
                    "key": "code",
                    "type": "Number"
                },
                {
                    "key": "message",
                    "type": "String"
                },
                {
                    "key": "stackTrace",
                    "type": "String"
                }
            ],
            "public": false,
            "_lastUpdated": "2025-11-17T06:57:15.070Z",
            "_createdAt": "2025-11-09T05:31:02.922Z",
            "code": "const jsonata = require('jsonata');\n\nfunction setNestedValue(obj, path, value) {\n    const parts = path.split('.');\n    let current = obj;\n    for (let i = 0; i < parts.length - 1; i++) {\n        const part = parts[i];\n        if (!(part in current)) current[part] = {};\n        current = current[part];\n    }\n    current[parts[parts.length - 1]] = value;\n}\n\nfunction getNestedValue(obj, path) {\n    const parts = path.split('.');\n    let current = obj;\n    for (const part of parts) {\n        if (current === null || current === undefined) return undefined;\n        current = current[part];\n    }\n    return current;\n}\n\nfunction mergeArrayFieldMappings(fieldMappings) {\n    if (fieldMappings.size === 0) return [];\n\n    const fieldNames = Array.from(fieldMappings.keys());\n    const maxLength = Math.max(...fieldNames.map(name => fieldMappings.get(name).length));\n    const result = [];\n\n    for (let i = 0; i < maxLength; i++) {\n        const mergedObject = {};\n        for (const fieldName of fieldNames) {\n            const fieldArray = fieldMappings.get(fieldName);\n            if (i < fieldArray.length && fieldArray[i] !== null && fieldArray[i] !== undefined) {\n                mergedObject[fieldName] = fieldArray[i];\n            }\n        }\n        if (Object.keys(mergedObject).length > 0) {\n            result.push(mergedObject);\n        }\n    }\n    return result;\n}\n\nasync function transformData(sourceData, targetData, mappings) {\n    const result = {};\n    const arrayFieldMappings = new Map();\n\n    for (const mapping of mappings) {\n        try {\n            const expression = jsonata(mapping.transformationCode);\n            const transformedValue = await expression.evaluate(sourceData);\n\n            if (transformedValue !== undefined && transformedValue !== null) {\n                const targetValue = getNestedValue(targetData, mapping.targetPath);\n                const targetIsArray = Array.isArray(targetValue);\n                const targetPathParts = mapping.targetPath.split('.');\n                const isFieldMapping = targetPathParts.length > 1 && !targetIsArray;\n\n                if (isFieldMapping && Array.isArray(transformedValue)) {\n                    const fieldName = targetPathParts[targetPathParts.length - 1];\n                    const arrayPath = targetPathParts.slice(0, -1).join('.');\n\n                    if (!arrayFieldMappings.has(arrayPath)) {\n                        arrayFieldMappings.set(arrayPath, new Map());\n                    }\n                    arrayFieldMappings.get(arrayPath).set(fieldName, transformedValue);\n                } else {\n                    setNestedValue(result, mapping.targetPath, transformedValue);\n                }\n            }\n        } catch (error) {\n            console.error(`Transformation failed for ${mapping.targetPath}:`, error);\n        }\n    }\n\n    for (const [arrayPath, fieldMappings] of arrayFieldMappings) {\n        const mergedArray = mergeArrayFieldMappings(fieldMappings);\n        setNestedValue(result, arrayPath, mergedArray);\n    }\n\n    console.log(JSON.stringify(result));\n    return result;\n}\n\nconst { sourceData, targetData, mappings } = inputData;\nlogger.trace(\"Sample source data\", JSON.stringify(sourceData));\nlogger.trace(\"Sample target data\", JSON.stringify(targetData));\nlogger.trace(\"Mappings array\", JSON.stringify(mappings));\nif (!Array.isArray(mappings)) {\n    throw new Error('Mappings array is required for transformation');\n}\n\ndata = await transformData(sourceData, targetData, mappings);\nreturn data;",
            "nodeId": "8ee1f419563d882ed9b5e4e6ef260766e88b0d27ff4277dac1ec3db36e64bcb0",
            "__v": 3
        }
    ]
}